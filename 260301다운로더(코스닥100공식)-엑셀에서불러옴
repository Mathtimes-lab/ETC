import sys
import os
import time
import pandas as pd
from datetime import datetime, timedelta
from PyQt5.QtWidgets import QApplication
from PyQt5.QAxContainer import QAxWidget
from PyQt5.QtCore import QEventLoop

class KiwoomDownloader(QAxWidget):
    def __init__(self):
        super().__init__()
        self._create_kiwoom_instance()
        self._set_signal_slots()
        self._login()

        self.remained_data = False
        self.ohlcv_data = []
        self.screen_no = "0101"
        
        # ìŠ¤ë§ˆíŠ¸ ë”œë ˆì´ë¥¼ ìœ„í•œ TR ìš”ì²­ íƒ€ì„ìŠ¤íƒ¬í”„ ê¸°ë¡ ë¦¬ìŠ¤íŠ¸
        self.tr_timestamps = []

    def _create_kiwoom_instance(self):
        self.setControl("KHOPENAPI.KHOpenAPICtrl.1")

    def _set_signal_slots(self):
        self.OnEventConnect.connect(self._on_event_connect)
        self.OnReceiveTrData.connect(self._on_receive_tr_data)

    def _login(self):
        self.login_event_loop = QEventLoop()
        self.dynamicCall("CommConnect()")
        self.login_event_loop.exec_()

    def _on_event_connect(self, err_code):
        if err_code == 0:
            print("âœ… í‚¤ì›€ API ë¡œê·¸ì¸ ì„±ê³µ")
        else:
            print(f"âŒ ë¡œê·¸ì¸ ì‹¤íŒ¨ (ì—ëŸ¬ì½”ë“œ: {err_code})")
        self.login_event_loop.exit()

    def get_stock_name(self, code):
        return self.dynamicCall("GetMasterCodeName(QString)", [code]).strip()

    def get_stock_state(self, code):
        return self.dynamicCall("GetMasterStockState(QString)", [code])

    # ìŠ¤ë§ˆíŠ¸ ë”œë ˆì´ ë°©ì–´ ë¡œì§ (ìš”ì²­ íšŸìˆ˜ ì œí•œ ëª¨ë‹ˆí„°ë§)
    def _check_tr_limit(self):
        now = time.time()
        
        # 1ì‹œê°„ ì´ìƒ ì§€ë‚œ ê¸°ë¡ì€ íì—ì„œ ì œê±°
        self.tr_timestamps = [t for t in self.tr_timestamps if now - t <= 3600]

        # 1. ì´ˆë‹¹ 5íšŒ ì œí•œ ë°©ì–´
        recent_1s = [t for t in self.tr_timestamps if now - t <= 1]
        if len(recent_1s) >= 4:
            time.sleep(1)
            now = time.time()

        # 2. ë¶„ë‹¹ 100íšŒ ì œí•œ ë°©ì–´
        recent_60s = [t for t in self.tr_timestamps if now - t <= 60]
        if len(recent_60s) >= 90:
            print(f"\nâ³ [ìŠ¤ë§ˆíŠ¸ ë”œë ˆì´] 1ë¶„ ì œí•œ(100íšŒ) ë„ë‹¬ ì„ë°•. 60ì´ˆê°„ ìˆ¨ì„ ê³ ë¦…ë‹ˆë‹¤...")
            time.sleep(60)
            now = time.time()

        # 3. ì‹œê°„ë‹¹ 1000íšŒ ì œí•œ ë°©ì–´
        if len(self.tr_timestamps) >= 950:
            sleep_time = 3600 - (now - self.tr_timestamps[0]) + 10 # ì•ˆì „í•˜ê²Œ 10ì´ˆ ì¶”ê°€
            if sleep_time > 0:
                print(f"\nâ³ [ìŠ¤ë§ˆíŠ¸ ë”œë ˆì´] 1ì‹œê°„ ì œí•œ(1000íšŒ) ë„ë‹¬ ì„ë°•. ì„œë²„ ë³´í˜¸ë¥¼ ìœ„í•´ ì•½ {sleep_time/60:.1f}ë¶„ ëŒ€ê¸°í•©ë‹ˆë‹¤...")
                time.sleep(sleep_time)

        # í˜„ì¬ ìš”ì²­ ì‹œê°„ì„ íì— ì¶”ê°€í•˜ê³  ê¸°ë³¸ ë”œë ˆì´ ì ìš©
        self.tr_timestamps.append(time.time())
        time.sleep(0.3) 

    def request_daily_chart(self, code, date):
        self.ohlcv_data = []
        self.remained_data = True
        next_val = 0

        # ë‹¤ìš´ë¡œë“œ ëª©í‘œ ë‚ ì§œë¥¼ ì˜¤ëŠ˜ ê¸°ì¤€ 10ë…„ ì „ìœ¼ë¡œ ì„¤ì •
        target_date = datetime.now() - timedelta(days=3650)

        while self.remained_data:
            self.dynamicCall("SetInputValue(QString, QString)", "ì¢…ëª©ì½”ë“œ", code)
            self.dynamicCall("SetInputValue(QString, QString)", "ê¸°ì¤€ì¼ì", date)
            self.dynamicCall("SetInputValue(QString, QString)", "ìˆ˜ì •ì£¼ê°€êµ¬ë¶„", "1")
            
            # TR ìš”ì²­ ì§ì „ì— ìŠ¤ë§ˆíŠ¸ ë”œë ˆì´ ë¡œì§ ì‹¤í–‰
            self._check_tr_limit()
            self._comm_rq_data("opt10081", "ì£¼ì‹ì¼ë´‰ì°¨íŠ¸ì¡°íšŒ", next_val, self.screen_no)

            if self.ohlcv_data:
                last_date_str = self.ohlcv_data[-1][0]
                if last_date_str:
                    last_date_dt = datetime.strptime(last_date_str, "%Y%m%d")
                    # 10ë…„ ì „ ë‚ ì§œë³´ë‹¤ ì´ì „ ë°ì´í„°ê°€ ì¡°íšŒë˜ë©´ ì¤‘ë‹¨
                    if last_date_dt <= target_date:
                        break

            if self.remained_data:
                next_val = 2

        if not self.ohlcv_data:
            return pd.DataFrame()

        df = pd.DataFrame(self.ohlcv_data, columns=['Date', 'Open', 'High', 'Low', 'Close', 'Volume'])
        df['Date'] = pd.to_datetime(df['Date'])
        df = df.sort_values(by='Date').reset_index(drop=True)
        
        # 10ë…„ ì¹˜ ë°ì´í„° í•„í„°ë§
        df = df[df['Date'] >= target_date.strftime('%Y-%m-%d')]

        return df

    def _comm_rq_data(self, trcode, rqname, next_val, screen_no):
        self.tr_event_loop = QEventLoop()
        ret = self.dynamicCall("CommRqData(QString, QString, int, QString)", rqname, trcode, next_val, screen_no)
        if ret != 0:
            print(f"\nâŒ TR ìš”ì²­ ì‹¤íŒ¨ ({rqname}) - ì—ëŸ¬ì½”ë“œ: {ret}")
            self.remained_data = False
            return
        self.tr_event_loop.exec_()

    def _get_comm_data_int(self, trcode, rqname, index, item_name):
        val = self.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, index, item_name).strip()
        try:
            return abs(int(val)) if val else 0
        except ValueError:
            return 0

    def _on_receive_tr_data(self, screen_no, rqname, trcode, record_name, next_val, unused1, unused2, unused3, unused4):
        self.remained_data = (next_val == '2')
        count = self.dynamicCall("GetRepeatCnt(QString, QString)", trcode, rqname)

        for i in range(count):
            date = self.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, i, "ì¼ì").strip()
            open_ = self._get_comm_data_int(trcode, rqname, i, "ì‹œê°€")
            high = self._get_comm_data_int(trcode, rqname, i, "ê³ ê°€")
            low = self._get_comm_data_int(trcode, rqname, i, "ì €ê°€")
            close = self._get_comm_data_int(trcode, rqname, i, "í˜„ì¬ê°€")
            volume = self._get_comm_data_int(trcode, rqname, i, "ê±°ë˜ëŸ‰")

            self.ohlcv_data.append([date, open_, high, low, close, volume])

        self.tr_event_loop.exit()


def main():
    app = QApplication(sys.argv)

    print("ğŸš€ í‚¤ì›€ì¦ê¶Œ API ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ì¤‘...")
    kiwoom = KiwoomDownloader()

    # ì½”ìŠ¤ë‹¥ 100 ê³µì‹ ì¢…ëª© ì €ì¥ í´ë”ëª…
    save_dir = "stock_data_do100ten"
    if not os.path.exists(save_dir):
        os.makedirs(save_dir)

    print("\nâ³ 'do100' íŒŒì¼ì—ì„œ ì½”ìŠ¤ë‹¥ 100 ì¢…ëª© ë¦¬ìŠ¤íŠ¸ë¥¼ ì½ì–´ì˜µë‹ˆë‹¤...")
    official_codes = []

    # =========================================================================
    # ì‚¬ìš©ì ì œê³µ íŒŒì¼(do100.xlsx ë˜ëŠ” csv) ì§ì ‘ ë¡œë“œ
    # =========================================================================
    try:
        # xlsx íŒŒì¼ì„ ìš°ì„ ìœ¼ë¡œ ì°¾ê³  ì—†ìœ¼ë©´ csv í™•ì¸
        file_path = "do100.xlsx"
        if not os.path.exists(file_path):
            file_path = "do100.csv"
            
        if file_path.endswith('.xlsx'):
            df_codes = pd.read_excel(file_path)
        else:
            df_codes = pd.read_csv(file_path)

        # 'ì¢…ëª©ì½”ë“œ' ì»¬ëŸ¼ ì¶”ì¶œ. (ìˆ«ìí˜•ì¼ ê²½ìš° ì•ì˜ '0'ì´ ì˜ë¦¬ëŠ” ê²ƒì„ ë°©ì§€í•˜ê¸° ìœ„í•´ 6ìë¦¬ ë¬¸ìì—´ë¡œ ë³€í™˜)
        if 'ì¢…ëª©ì½”ë“œ' in df_codes.columns:
            official_codes = df_codes['ì¢…ëª©ì½”ë“œ'].apply(lambda x: str(x).split('.')[0].zfill(6)).tolist()
        else:
            # 'ì¢…ëª©ì½”ë“œ'ë¼ëŠ” ì •í™•í•œ ì´ë¦„ì´ ì—†ì„ ê²½ìš° ìœ ì—°í•˜ê²Œ ëŒ€ì‘
            code_col = [c for c in df_codes.columns if "ì½”ë“œ" in str(c) or "code" in str(c).lower()][0]
            official_codes = df_codes[code_col].apply(lambda x: str(x).split('.')[0].zfill(6)).tolist()
            
        print(f"âœ… íŒŒì¼({file_path})ì—ì„œ ì´ {len(official_codes)}ê°œì˜ ì¢…ëª©ì½”ë“œë¥¼ ì„±ê³µì ìœ¼ë¡œ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.")
        
    except Exception as e:
        print(f"\nâŒ ì¢…ëª© ë¦¬ìŠ¤íŠ¸ íŒŒì¼ì„ ì½ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {e}")
        print("ğŸ‘‰ 'do100.xlsx' (ë˜ëŠ” .csv) íŒŒì¼ì´ í˜„ì¬ íŒŒì´ì¬ ìŠ¤í¬ë¦½íŠ¸ì™€ ê°™ì€ í´ë”ì— ìˆëŠ”ì§€, ê·¸ë¦¬ê³  'ì¢…ëª©ì½”ë“œ' ì»¬ëŸ¼ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.")
        sys.exit()

    # ì¶”ì¶œëœ ì½”ë“œë“¤ì„ ë°”íƒ•ìœ¼ë¡œ ì‹¤ì œ í‚¤ì›€ì¦ê¶Œ HTSì— ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
    final_targets = []
    
    for code in official_codes:
        name = kiwoom.get_stock_name(code)
        
        # ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ì¢…ëª©ì´ê±°ë‚˜, ê´€ë¦¬/ì •ì§€ ì¢…ëª© í•„í„°ë§
        if not name: 
            print(f"âš ï¸ ì½”ë“œ {code} - HTSì— ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ì¢…ëª©ì½”ë“œì…ë‹ˆë‹¤. ì œì™¸í•©ë‹ˆë‹¤.")
            continue
        
        state = kiwoom.get_stock_state(code)
        if "ê´€ë¦¬ì¢…ëª©" in state or "ê±°ë˜ì •ì§€" in state or "ì •ë¦¬ë§¤ë§¤" in state:
            print(f"âš ï¸ {name}({code}) - {state} ìƒíƒœì´ë¯€ë¡œ ë‹¤ìš´ë¡œë“œì—ì„œ ì œì™¸í•©ë‹ˆë‹¤.")
            continue
            
        final_targets.append((code, name))

    print(f"âœ… ë‹¤ìš´ë¡œë“œ ê°€ëŠ¥ ê³µì‹ ì½”ìŠ¤ë‹¥ 100 ì¢…ëª© (ì´ {len(final_targets)}ê°œ) ì¤€ë¹„ ì™„ë£Œ")

    print("\nğŸš€ ë‹¤ìš´ë¡œë“œ ì‹œì‘ (ìµœê·¼ 10ë…„ ë°ì´í„° / ìŠ¤ë§ˆíŠ¸ ë”œë ˆì´ ê°€ë™ ì¤‘)...")

    today_str = datetime.now().strftime("%Y%m%d")
    total = len(final_targets)

    for idx, (code, name) in enumerate(final_targets):
        safe_name = name.replace("/", "_").replace("*", "").replace(":", "")
        
        # íŒŒì¼ëª…ì—ì„œ ìƒì¥ì£¼ì‹ìˆ˜ ì œì™¸
        file_path = os.path.join(save_dir, f"{code}_{safe_name}.xlsx")

        # ì´ì–´ë°›ê¸° ê¸°ëŠ¥: í´ë”ì— ì´ë¯¸ í•´ë‹¹ ì¢…ëª©ì˜ íŒŒì¼ì´ ì¡´ì¬í•˜ë©´ ë‹¤ìš´ë¡œë“œë¥¼ ê±´ë„ˆëœ€
        if os.path.exists(file_path):
            print(f"[{idx + 1}/{total}] [KOSDAQ 100] {name} ({code}) ì´ë¯¸ ì¡´ì¬í•¨ (ê±´ë„ˆëœ€)")
            continue

        print(f"[{idx + 1}/{total}] [KOSDAQ 100] {name} ({code}) ìš”ì²­ ì¤‘...", end=" ", flush=True)

        try:
            df = kiwoom.request_daily_chart(code, today_str)

            if not df.empty:
                df.to_excel(file_path, index=False)
                print(f"ì™„ë£Œ ({len(df)}ê±´)")
            else:
                print("ë°ì´í„° ì—†ìŒ")

        except Exception as e:
            print(f"ì‹¤íŒ¨ ({e})")

    print(f"\nğŸ‰ '{save_dir}' í´ë”ì— ì—‘ì…€ ë¦¬ìŠ¤íŠ¸ ê¸°ì¤€ ì½”ìŠ¤ë‹¥ 100 ì¢…ëª©ì˜ 10ë…„ ì¹˜ ë‹¤ìš´ë¡œë“œê°€ ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!")
    sys.exit()


if __name__ == "__main__":
    main()
