import sys
import time
import os
import math
import pandas as pd  # ë°ì´í„° ì €ì¥/ìˆ˜ì •ìš©
import numpy as np  # ë‚ ì§œ ê³„ì‚°ìš©
from datetime import datetime
from PyQt5.QtWidgets import *
from PyQt5.QAxContainer import *
from PyQt5.QtCore import *


class Kiwoom(QMainWindow):
    def __init__(self):
        super().__init__()

        # --- [ì„¤ì • êµ¬ê°„] ---
        self.BUY_STRATEGY_NAME = "260218ê¸‰ë“±ê¸°ë³¸"
        self.SELL_STRATEGY_NAME = "260218ë§¤ë„ì‹"
        self.CSV_FILE_NAME = "trade_history(real).csv"  # ì €ì¥í•  íŒŒì¼ëª…

        # [ì¶”ê°€] ë§¤ìˆ˜/ë§¤ë„ ê¸ˆì•¡ ë° í˜¸ê°€ ì„¤ì •
        self.MAX_BUY_AMOUNT = 500000  # 1íšŒ ìµœëŒ€ ë§¤ìˆ˜ ê¸ˆì•¡ (ì›)
        self.BUY_ORDER_TYPE = "03"  # ë§¤ìˆ˜ í˜¸ê°€êµ¬ë¶„: "00"(ì§€ì •ê°€), "03"(ì‹œì¥ê°€)
        self.SELL_ORDER_TYPE = "03"  # ë§¤ë„ í˜¸ê°€êµ¬ë¶„: "00"(ì§€ì •ê°€), "03"(ì‹œì¥ê°€)
        # -----------------

        self.account_num = None
        self.bought_today = []  # ì˜¤ëŠ˜ ë§¤ìˆ˜í•œ ì¢…ëª© ë¦¬ìŠ¤íŠ¸
        self.sold_today = []  # ì˜¤ëŠ˜ ë§¤ë„í•œ ì¢…ëª© ë¦¬ìŠ¤íŠ¸ (ì¬ë§¤ìˆ˜ ë°©ì§€ìš©)

        # ë³´ìœ  ì¢…ëª© ê´€ë¦¬: { 'ì¢…ëª©ì½”ë“œ': {'qty': ìˆ˜ëŸ‰, 'price': ë‹¨ê°€, ...} }
        self.held_stocks = {}

        # ë§¤ìˆ˜ ì£¼ë¬¸ ì‹œì ì˜ ë©”íƒ€ ë°ì´í„° ì„ì‹œ ì €ì¥ (ì²´ê²° ì „ê¹Œì§€ ë³´ê´€)
        self.buy_meta_data = {}

        # TR ìš”ì²­ ë°ì´í„° ì„ì‹œ ì €ì¥ìš© (ë™ê¸° í†µì‹ ìš©)
        self.tr_data_temp = {}

        self.open_buy_orders = {}  # ë¯¸ì²´ê²° ë§¤ìˆ˜ ì£¼ë¬¸ ê´€ë¦¬

        self.current_deposit = 0  # [ì‹ ê·œ] ì‹¤ì‹œê°„ ì˜ˆìˆ˜ê¸ˆ ì”ì•¡ ì¶”ì ìš©

        # í˜„ì¬ ì‹¤ì‹œê°„ ì¡°ê±´ ë§Œì¡± ì¢…ëª© ê´€ë¦¬ (ëª¨ë‹ˆí„°ë§ìš©)
        self.current_conditioned_stocks = set()

        # [ì‹ ê·œ] ì¡°ê±´ê²€ìƒ‰ ê°€ë™ ì—¬ë¶€ í”Œë˜ê·¸ (ì¥ì™¸ ì‹œê°„ ëŒ€ê¸°ìš©)
        self.condition_started = False

        # ì‘ì—… ëŒ€ê¸°ì—´(Queue) ì‹œìŠ¤í…œ (TR ê³¼ë¶€í•˜ ë° ê°•ì œì¢…ë£Œ 0xC0000409 ë°©ì§€)
        self.job_queue = []
        self.is_processing_job = False  # ì‘ì—… ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€ìš© ë½(Lock)

        # [ì‹ ê·œ] ì—‘ì…€(CSV) ë©”ëª¨ë¦¬ ë²„í¼ ë° ì¼ê´„ ì €ì¥(Debounce) íƒ€ì´ë¨¸ ì„¤ì •
        self.history_df = pd.DataFrame()
        self._load_csv_to_memory()

        self.csv_save_timer = QTimer(self)
        self.csv_save_timer.setSingleShot(True)
        self.csv_save_timer.timeout.connect(self._save_csv_to_disk)

        # í‚¤ì›€ OCX ìƒì„±
        self.kiwoom = QAxWidget("KHOPENAPI.KHOpenAPICtrl.1")

        # API íŒì—… ì–µì œ
        self.kiwoom.dynamicCall("KOA_Functions(QString, QString)", "SetShowMessage", "0")

        # ì´ë²¤íŠ¸ ì—°ê²°
        self.kiwoom.OnEventConnect.connect(self._event_connect)
        self.kiwoom.OnReceiveConditionVer.connect(self._handler_condition_load)
        self.kiwoom.OnReceiveTrData.connect(self._handler_tr_data)
        self.kiwoom.OnReceiveMsg.connect(self._handler_msg)

        try:
            self.kiwoom.OnReceiveTrCondition.connect(self._handler_condition)
        except AttributeError:
            self.kiwoom.OnReceiveCondition.connect(self._handler_condition)

        self.kiwoom.OnReceiveRealCondition.connect(self._handler_real_condition)
        self.kiwoom.OnReceiveChejanData.connect(self._handler_chejan_data)

        # ì‹œìŠ¤í…œ ì ê²€ ë° ë¯¸ì²´ê²° ì·¨ì†Œ íƒ€ì´ë¨¸ (1ë¶„)
        self.periodic_timer = QTimer(self)
        self.periodic_timer.timeout.connect(self._periodic_check)
        self.periodic_timer.start(60000)

        # ìŠ¬ë¦¬í”¼ì§€ ë¶„ì„ ë¦¬í¬íŠ¸ íƒ€ì´ë¨¸ (5ë¶„)
        self.slippage_timer = QTimer(self)
        self.slippage_timer.timeout.connect(self._print_slippage_report)
        self.slippage_timer.start(300000)

        # 0xC0000409 ì—ëŸ¬ ë°©ì§€ë¥¼ ìœ„í•´, ë‹¨ë°œì„±(SingleShot) íƒ€ì´ë¨¸ë¡œ í ì²˜ë¦¬ ì‹œì‘
        QTimer.singleShot(1000, self._process_job_queue)

    # -------------------------------------
    # [ìœ í‹¸] ì•ˆì „í•œ ë”œë ˆì´ (GUI/ì´ë²¤íŠ¸ ë©ˆì¶¤ ë°©ì§€)
    # -------------------------------------
    def _safe_delay(self, ms):
        """time.sleep ëŒ€ì‹  ì‚¬ìš©í•˜ì—¬ ì´ë²¤íŠ¸ ë£¨í”„ê°€ ë©ˆì¶”ì§€ ì•Šë„ë¡ í•¨"""
        loop = QEventLoop()
        QTimer.singleShot(ms, loop.quit)
        loop.exec_()

    # -------------------------------------
    # [ìœ í‹¸] ì—‘ì…€ ë©”ëª¨ë¦¬ ë¡œë”© ë° ë””ë°”ìš´ì‹±(ì¼ê´„ ì €ì¥) ë¡œì§
    # -------------------------------------
    def _load_csv_to_memory(self):
        """ì‹œì‘ ì‹œ ë‹¨ 1íšŒë§Œ CSV íŒŒì¼ì„ ë©”ëª¨ë¦¬(history_df)ì— ë¡œë“œí•˜ì—¬ ë³‘ëª© ì°¨ë‹¨"""
        columns = [
            'ì¢…ëª©ì½”ë“œ', 'ì¢…ëª©ëª…', 'ë§¤ìˆ˜ì¼', 'ë§¤ìˆ˜ì‹œê°„', 'ë§¤ìˆ˜ëª©í‘œê°€', 'ì‹¤ì œë§¤ì…ê°€', 'ë§¤ìˆ˜ìŠ¬ë¦¬í”¼ì§€(%)',
            'ë§¤ë„ì¼', 'ë§¤ë„ì‹œê°„', 'ë§¤ë„ëª©í‘œê°€', 'ì‹¤ì œë§¤ë„ê°€', 'ë§¤ë„ìŠ¬ë¦¬í”¼ì§€(%)', 'í•©ì‚°ìŠ¬ë¦¬í”¼ì§€(%)',
            'í…ŒìŠ¤íŠ¸ìˆ˜ìµë¥ (%)', 'ì‹¤ì œìˆ˜ìµë¥ (%)', 'ë³´ìœ ê¸°ê°„(ì¼)'
        ]
        if os.path.exists(self.CSV_FILE_NAME):
            try:
                df = pd.read_csv(self.CSV_FILE_NAME, dtype={'ì¢…ëª©ì½”ë“œ': str})
                self.history_df = self._migrate_history_columns(df)
                self.history_df['ì¢…ëª©ì½”ë“œ'] = self.history_df['ì¢…ëª©ì½”ë“œ'].astype(str).str.replace("'", "").str.zfill(6)
                
                # ì¬ì‹œì‘ ì‹œ ë‹¹ì¼ ë§¤ë„ ê¸°ë¡ ë³µêµ¬ (ë‹¹ì¼ ì¬ë§¤ìˆ˜ ë°©ì§€)
                today_str = datetime.now().strftime('%Y-%m-%d')
                sold_mask = self.history_df['ë§¤ë„ì¼'] == today_str
                for c in self.history_df.loc[sold_mask, 'ì¢…ëª©ì½”ë“œ'].unique():
                    if c not in self.sold_today:
                        self.sold_today.append(c)
            except Exception as e:
                print(f"[ì˜¤ë¥˜] CSV íŒŒì¼ ë©”ëª¨ë¦¬ ë¡œë“œ ì‹¤íŒ¨: {e}")
                self.history_df = pd.DataFrame(columns=columns)
        else:
            self.history_df = pd.DataFrame(columns=columns)

    def _save_csv_to_disk(self):
        """5ì´ˆê°„ ì•„ë¬´ëŸ° ê±°ë˜ ì´ë²¤íŠ¸ê°€ ì—†ìœ¼ë©´(í•œê°€í•  ë•Œ) ë©”ëª¨ë¦¬ì˜ ë°ì´í„°ë¥¼ CSVì— í•œë°©ì— ì¼ê´„ ì €ì¥"""
        if not self.history_df.empty:
            try:
                save_df = self.history_df.copy()
                save_df['ì¢…ëª©ì½”ë“œ'] = save_df['ì¢…ëª©ì½”ë“œ'].apply(lambda x: f"'{x}" if not str(x).startswith("'") else x)
                save_df.to_csv(self.CSV_FILE_NAME, index=False, encoding='utf-8-sig')
                print(f"\n[{datetime.now().strftime('%H:%M:%S')}] ğŸ’¾ [ì¼ê´„ì €ì¥] ì´ë²¤íŠ¸ í•œì‚°ê¸° ë„ë‹¬, ê±°ë˜ ë‚´ì—­ ì—‘ì…€ íŒŒì¼ ì•ˆì „ ê¸°ë¡ ì™„ë£Œ.\n")
            except Exception as e:
                print(f"\n[ê²½ê³ ] ì—‘ì…€ ì¼ê´„ ì €ì¥ ì‹¤íŒ¨ (íŒŒì¼ì´ ì—´ë ¤ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë°ì´í„°ëŠ” ë©”ëª¨ë¦¬ì— ë³´ì¡´ë¨): {e}\n")

    def _migrate_history_columns(self, df):
        rename_map = {
            '5%ìƒìŠ¹ê°€(ë³´ì •X)': 'ë§¤ìˆ˜ëª©í‘œê°€',
            'ëª©í‘œê°€(ë³´ì •X)': 'ë§¤ìˆ˜ëª©í‘œê°€',
            'ìŠ¬ë¦¬í”¼ì§€(%)': 'ë§¤ìˆ˜ìŠ¬ë¦¬í”¼ì§€(%)',
            'ë§¤ë„ê°€ê²©': 'ì‹¤ì œë§¤ë„ê°€',
            'ìˆ˜ìµë¥ (%)': 'ì‹¤ì œìˆ˜ìµë¥ (%)'
        }
        for old, new in rename_map.items():
            if old in df.columns:
                df = df.rename(columns={old: new})

        for col in ['ë§¤ë„ëª©í‘œê°€', 'ë§¤ë„ìŠ¬ë¦¬í”¼ì§€(%)', 'í•©ì‚°ìŠ¬ë¦¬í”¼ì§€(%)', 'í…ŒìŠ¤íŠ¸ìˆ˜ìµë¥ (%)']:
            if col not in df.columns:
                df[col] = ''

        return df

    def _get_hoga_unit(self, price):
        if price < 2000:
            return 1
        elif price < 5000:
            return 5
        elif price < 20000:
            return 10
        elif price < 50000:
            return 50
        elif price < 200000:
            return 100
        elif price < 500000:
            return 500
        else:
            return 1000

    def _adjust_price_to_tick(self, price):
        unit = self._get_hoga_unit(price)
        return int(round(price / unit) * unit)

    # -------------------------------------
    # [í•µì‹¬] CSV ë©”ëª¨ë¦¬ ê¸°ë°˜ ì´ë ¥ ê´€ë¦¬ ë¡œì§ (ë””ìŠ¤í¬ I/O ì™„ì „ ì œê±°)
    # -------------------------------------
    def _log_buy_trade(self, code, stock_name, buy_date, buy_time, target_raw, buy_price, slippage):
        """ë§¤ìˆ˜ ì²´ê²° ì‹œ: ë©”ëª¨ë¦¬(history_df)ì— ì‹ ê·œ í–‰ ìƒì„±"""
        if not self.history_df.empty:
            is_duplicate = not self.history_df[
                (self.history_df['ì¢…ëª©ì½”ë“œ'] == code) &
                (self.history_df['ë§¤ìˆ˜ì¼'] == buy_date) &
                (self.history_df['ë§¤ìˆ˜ì‹œê°„'] == buy_time)
                ].empty
            if is_duplicate:
                return

        new_data = {
            'ì¢…ëª©ì½”ë“œ': code,
            'ì¢…ëª©ëª…': stock_name,
            'ë§¤ìˆ˜ì¼': buy_date,
            'ë§¤ìˆ˜ì‹œê°„': buy_time,
            'ë§¤ìˆ˜ëª©í‘œê°€': int(target_raw),
            'ì‹¤ì œë§¤ì…ê°€': buy_price,
            'ë§¤ìˆ˜ìŠ¬ë¦¬í”¼ì§€(%)': round(slippage, 2),
            'ë§¤ë„ì¼': '', 'ë§¤ë„ì‹œê°„': '', 'ë§¤ë„ëª©í‘œê°€': '', 'ì‹¤ì œë§¤ë„ê°€': '',
            'ë§¤ë„ìŠ¬ë¦¬í”¼ì§€(%)': '', 'í•©ì‚°ìŠ¬ë¦¬í”¼ì§€(%)': '', 'í…ŒìŠ¤íŠ¸ìˆ˜ìµë¥ (%)': '',
            'ì‹¤ì œìˆ˜ìµë¥ (%)': '', 'ë³´ìœ ê¸°ê°„(ì¼)': ''
        }

        self.history_df = pd.concat([self.history_df, pd.DataFrame([new_data])], ignore_index=True)
        print(f"[ê¸°ë¡ëŒ€ê¸°] ë§¤ìˆ˜ ì´ë ¥ ë©”ëª¨ë¦¬ ë“±ë¡ ì™„ë£Œ: {stock_name}")
        self.csv_save_timer.start(5000)  # 5ì´ˆ ë””ë°”ìš´ì‹± íƒ€ì´ë¨¸ ê°€ë™

    def _log_sell_trade(self, code, stock_name, sell_date, sell_time, sell_target_price, actual_sell_price):
        """ë§¤ë„ ì²´ê²° ì‹œ: ë©”ëª¨ë¦¬(history_df)ì— ë§¤ë„ ì •ë³´ ì—…ë°ì´íŠ¸"""
        if self.history_df.empty:
            print(f"[ì˜¤ë¥˜] ë©”ëª¨ë¦¬ ê¸°ë¡ì´ ì—†ì–´ ë§¤ë„ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {stock_name}")
            return

        mask = (self.history_df['ì¢…ëª©ì½”ë“œ'] == code) & (self.history_df['ë§¤ë„ì¼'].isna() | (self.history_df['ë§¤ë„ì¼'] == ''))
        if not self.history_df.loc[mask].empty:
            idx = self.history_df.loc[mask].index[-1]

            try:
                buy_target = float(self.history_df.loc[idx, 'ë§¤ìˆ˜ëª©í‘œê°€'])
            except:
                buy_target = float(self.history_df.loc[idx, 'ì‹¤ì œë§¤ì…ê°€'])

            try:
                buy_price = float(self.history_df.loc[idx, 'ì‹¤ì œë§¤ì…ê°€'])
            except:
                buy_price = 0.0

            try:
                buy_slippage = float(self.history_df.loc[idx, 'ë§¤ìˆ˜ìŠ¬ë¦¬í”¼ì§€(%)'])
            except:
                buy_slippage = 0.0

            buy_date = str(self.history_df.loc[idx, 'ë§¤ìˆ˜ì¼'])
            try:
                hold_days = np.busday_count(buy_date, sell_date)
            except:
                hold_days = 0

            sell_slippage = ((
                                         sell_target_price - actual_sell_price) / sell_target_price * 100) if sell_target_price > 0 else 0.0
            total_slippage = buy_slippage + sell_slippage

            test_return = ((sell_target_price - buy_target) / buy_target * 100) if buy_target > 0 else 0.0
            actual_return = ((actual_sell_price - buy_price) / buy_price * 100) if buy_price > 0 else 0.0

            self.history_df.loc[idx, 'ë§¤ë„ì¼'] = sell_date
            self.history_df.loc[idx, 'ë§¤ë„ì‹œê°„'] = sell_time
            self.history_df.loc[idx, 'ë§¤ë„ëª©í‘œê°€'] = int(sell_target_price)
            self.history_df.loc[idx, 'ì‹¤ì œë§¤ë„ê°€'] = int(actual_sell_price)
            self.history_df.loc[idx, 'ë§¤ë„ìŠ¬ë¦¬í”¼ì§€(%)'] = round(sell_slippage, 2)
            self.history_df.loc[idx, 'í•©ì‚°ìŠ¬ë¦¬í”¼ì§€(%)'] = round(total_slippage, 2)
            self.history_df.loc[idx, 'í…ŒìŠ¤íŠ¸ìˆ˜ìµë¥ (%)'] = round(test_return, 2)
            self.history_df.loc[idx, 'ì‹¤ì œìˆ˜ìµë¥ (%)'] = round(actual_return, 2)
            self.history_df.loc[idx, 'ë³´ìœ ê¸°ê°„(ì¼)'] = hold_days

            print(f"[ê¸°ë¡ëŒ€ê¸°] ë§¤ë„ ì´ë ¥ ë©”ëª¨ë¦¬ ì—…ë°ì´íŠ¸ ì™„ë£Œ: {stock_name} (ì‹¤ì œìˆ˜ìµë¥ : {actual_return:.2f}%)")
            self.csv_save_timer.start(5000)
        else:
            print(f"[ì•Œë¦¼] '{stock_name}'ì˜ ë§¤ìˆ˜ ê¸°ë¡ì„ ì°¾ì„ ìˆ˜ ì—†ì–´ ë§¤ë„ ê¸°ë¡ë§Œ ë³„ë„ë¡œ ë‚¨ê¸¸ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    def _update_csv_target_price(self, code, target_price, order_type):
        """ì‚¬í›„ ê³„ì‚°ëœ ë°±í…ŒìŠ¤íŠ¸ ëª©í‘œê°€ë¥¼ ë©”ëª¨ë¦¬(history_df)ì— ì—…ë°ì´íŠ¸"""
        if self.history_df.empty: return
        try:
            if order_type == 'BUY':
                mask = (self.history_df['ì¢…ëª©ì½”ë“œ'] == code) & (
                            self.history_df['ë§¤ë„ì¼'].isna() | (self.history_df['ë§¤ë„ì¼'] == ''))
                if not self.history_df.loc[mask].empty:
                    idx = self.history_df.loc[mask].index[-1]
                    self.history_df.loc[idx, 'ë§¤ìˆ˜ëª©í‘œê°€'] = int(target_price)
                    buy_price = float(self.history_df.loc[idx, 'ì‹¤ì œë§¤ì…ê°€'])
                    if target_price > 0:
                        self.history_df.loc[idx, 'ë§¤ìˆ˜ìŠ¬ë¦¬í”¼ì§€(%)'] = round(((buy_price - target_price) / target_price) * 100,
                                                                      2)
                    self.csv_save_timer.start(5000)

            elif order_type == 'SELL':
                mask = (self.history_df['ì¢…ëª©ì½”ë“œ'] == code)
                if not self.history_df.loc[mask].empty:
                    idx = self.history_df.loc[mask].index[-1]
                    self.history_df.loc[idx, 'ë§¤ë„ëª©í‘œê°€'] = int(target_price)
                    actual_sell = float(self.history_df.loc[idx, 'ì‹¤ì œë§¤ë„ê°€'])
                    if target_price > 0:
                        sell_slip = ((target_price - actual_sell) / target_price) * 100
                        self.history_df.loc[idx, 'ë§¤ë„ìŠ¬ë¦¬í”¼ì§€(%)'] = round(sell_slip, 2)
                        try:
                            buy_slip = float(self.history_df.loc[idx, 'ë§¤ìˆ˜ìŠ¬ë¦¬í”¼ì§€(%)'])
                        except:
                            buy_slip = 0.0
                        self.history_df.loc[idx, 'í•©ì‚°ìŠ¬ë¦¬í”¼ì§€(%)'] = round(buy_slip + sell_slip, 2)
                        try:
                            buy_target = float(self.history_df.loc[idx, 'ë§¤ìˆ˜ëª©í‘œê°€'])
                        except:
                            buy_target = float(self.history_df.loc[idx, 'ì‹¤ì œë§¤ì…ê°€'])
                        if buy_target > 0:
                            self.history_df.loc[idx, 'í…ŒìŠ¤íŠ¸ìˆ˜ìµë¥ (%)'] = round(
                                ((target_price - buy_target) / buy_target) * 100, 2)
                    self.csv_save_timer.start(5000)
        except Exception:
            pass

    # -------------------------------------
    # ì´ˆê¸°í™” ì²´ì¸
    # -------------------------------------
    def _req_outstanding_orders(self):
        print("[ì‹œìŠ¤í…œ] ë¯¸ì²´ê²° ì£¼ë¬¸ ë‚´ì—­ì„ í™•ì¸í•©ë‹ˆë‹¤...")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ê³„ì¢Œë²ˆí˜¸", self.account_num)
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ì „ì²´ì¢…ëª©êµ¬ë¶„", "0")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ë§¤ë§¤êµ¬ë¶„", "0")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ì²´ê²°êµ¬ë¶„", "1")
        self.kiwoom.dynamicCall("CommRqData(QString, QString, int, QString)", "ë¯¸ì²´ê²°ìš”ì²­", "opt10075", 0, "0102")

    def _req_account_balance(self, prev_next="0"):
        # [ìˆ˜ì •] ë³´ìœ ì¢…ëª©ì´ 20ê°œë¥¼ ì´ˆê³¼í•  ê²½ìš°(í˜ì´ì§•)ë¥¼ ì§€ì›í•˜ê¸° ìœ„í•´ prev_next íŒŒë¼ë¯¸í„° ì¶”ê°€
        if prev_next == "0":
            print("[ì‹œìŠ¤í…œ] ë³´ìœ  ì¢…ëª©(ê³„ì¢Œ ì”ê³ )ì„ í™•ì¸í•©ë‹ˆë‹¤...")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ê³„ì¢Œë²ˆí˜¸", self.account_num)
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ë¹„ë°€ë²ˆí˜¸", "")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ë¹„ë°€ë²ˆí˜¸ì…ë ¥ë§¤ì²´êµ¬ë¶„", "00")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ì¡°íšŒêµ¬ë¶„", "2")
        # 0ì´ë©´ ì²˜ìŒë¶€í„° ì¡°íšŒ, 2ì´ë©´ ë‹¤ìŒ í˜ì´ì§€(ì—°ì†)ë¶€í„° ì¡°íšŒí•©ë‹ˆë‹¤.
        self.kiwoom.dynamicCall("CommRqData(QString, QString, int, QString)", "ì”ê³ ìš”ì²­", "opw00018", int(prev_next), "0103")

    def _req_deposit(self):
        """[ì‹ ê·œ] ì˜ˆìˆ˜ê¸ˆ ìƒì„¸ í˜„í™©(ì£¼ë¬¸ê°€ëŠ¥ê¸ˆì•¡) ìš”ì²­"""
        if not self.account_num: return
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ê³„ì¢Œë²ˆí˜¸", self.account_num)
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ë¹„ë°€ë²ˆí˜¸", "")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ë¹„ë°€ë²ˆí˜¸ì…ë ¥ë§¤ì²´êµ¬ë¶„", "00")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ì¡°íšŒêµ¬ë¶„", "2")
        self.kiwoom.dynamicCall("CommRqData(QString, QString, int, QString)", "ì˜ˆìˆ˜ê¸ˆìš”ì²­", "opw00001", 0, "0105")

    def _get_stock_info(self, code):
        """TRìš”ì²­(opt10081)ìœ¼ë¡œ ë‹¹ì¼ ì‹œê°€ ë° ê³¼ê±° ì¼ë´‰(4ì¼ì¹˜) ë°ì´í„° í™•ì¸ (Sync)"""
        self.tr_data_temp = {}
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ì¢…ëª©ì½”ë“œ", code)
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ê¸°ì¤€ì¼ì", "")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ìˆ˜ì •ì£¼ê°€êµ¬ë¶„", "1")
        res = self.kiwoom.dynamicCall("CommRqData(QString, QString, int, QString)", "ì£¼ì‹ì¼ë´‰ê¸°ë³¸ìš”ì²­", "opt10081", 0, "0104")

        if res != 0:
            print(f"[ì‹œìŠ¤í…œ] ì„œë²„ ê³¼ë¶€í•˜ë¡œ ì£¼ì‹ì¼ë´‰ê¸°ë³¸ìš”ì²­(opt10081) ì°¨ë‹¨ë¨ (ì—ëŸ¬ì½”ë“œ: {res})")
            return self.tr_data_temp

        self.tr_event_loop = QEventLoop()
        QTimer.singleShot(3000, self.tr_event_loop.quit)
        self.tr_event_loop.exec_()

        return self.tr_data_temp

    def _handler_tr_data(self, scr_no, rqname, trcode, recordname, prev_next, data_len, err_code, msg, splm_msg):
        if rqname == "ë¯¸ì²´ê²°ìš”ì²­":
            cnt = self.kiwoom.dynamicCall("GetRepeatCnt(QString, QString)", trcode, rqname)
            for i in range(cnt):
                code = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, i,
                                               "ì¢…ëª©ì½”ë“œ").strip()
                order_no = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, i,
                                                   "ì£¼ë¬¸ë²ˆí˜¸").strip()
                order_type = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, i,
                                                     "ì£¼ë¬¸êµ¬ë¶„").strip()
                if "ë§¤ìˆ˜" in order_type:
                    self.open_buy_orders[code] = order_no
            print(f"[ì‹œìŠ¤í…œ] ë¯¸ì²´ê²° ë§¤ìˆ˜ ì£¼ë¬¸ ë³µì›: {len(self.open_buy_orders)}ê±´")
            QTimer.singleShot(200, self._req_account_balance)

        elif rqname == "ì”ê³ ìš”ì²­":
            cnt = self.kiwoom.dynamicCall("GetRepeatCnt(QString, QString)", trcode, rqname)
            for i in range(cnt):
                code = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, i,
                                               "ì¢…ëª©ë²ˆí˜¸").strip()
                code = code.replace("A", "")

                qty = int(self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, i,
                                                  "ë³´ìœ ìˆ˜ëŸ‰").strip())
                price = int(self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, i,
                                                    "ë§¤ì…ê°€").strip())

                if qty > 0:
                    target_raw = 0
                    buy_date = ''
                    buy_time = ''
                    csv_buy_price = price
                    csv_slippage = 0.0
                    is_restored_from_csv = False

                    if not self.history_df.empty:
                        mask = (self.history_df['ì¢…ëª©ì½”ë“œ'] == code) & (
                                    self.history_df['ë§¤ë„ì¼'].isna() | (self.history_df['ë§¤ë„ì¼'] == ''))
                        if not self.history_df.loc[mask].empty:
                            last_idx = self.history_df.loc[mask].index[-1]
                            try:
                                target_raw = int(self.history_df.loc[last_idx, 'ë§¤ìˆ˜ëª©í‘œê°€'])
                                buy_date = str(self.history_df.loc[last_idx, 'ë§¤ìˆ˜ì¼'])
                                buy_time = str(self.history_df.loc[last_idx, 'ë§¤ìˆ˜ì‹œê°„'])
                                csv_buy_price = float(self.history_df.loc[last_idx, 'ì‹¤ì œë§¤ì…ê°€'])
                                csv_slippage = float(self.history_df.loc[last_idx, 'ë§¤ìˆ˜ìŠ¬ë¦¬í”¼ì§€(%)'])
                                is_restored_from_csv = True
                            except Exception:
                                pass

                    if not is_restored_from_csv:
                        target_raw = price
                        csv_slippage = 0.0
                        buy_date = 'ìˆ˜ë™ë§¤ìˆ˜(ê¸°ë¡ì—†ìŒ)'
                        buy_time = '00:00:00'

                        stock_name = self.kiwoom.dynamicCall("GetMasterCodeName(QString)", code)
                        self._log_buy_trade(code, stock_name, buy_date, buy_time, target_raw, price, csv_slippage)

                    if buy_date == datetime.now().strftime('%Y-%m-%d'):
                        if code not in self.bought_today:
                            self.bought_today.append(code)

                    self.held_stocks[code] = {
                        'qty': qty, 'price': price, 'buy_date': buy_date, 'buy_time': buy_time,
                        'target_raw': target_raw, 'type': 'ì§€ì •ê°€',
                        'csv_buy_price': csv_buy_price,
                        'csv_slippage': csv_slippage
                    }

            # [ìˆ˜ì •] ì”ê³ ê°€ 20ê°œë¥¼ ì´ˆê³¼í•  ê²½ìš°(í˜ì´ì§•) ì²˜ë¦¬ ë¡œì§ ì¶”ê°€
            # í‚¤ì›€ APIëŠ” prev_next ì¸ìë¡œ "2"ê°€ ë“¤ì–´ì˜¤ë©´ ë‹¤ìŒ í˜ì´ì§€(ì—°ì† ë°ì´í„°)ê°€ ìˆë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤.
            if prev_next == "2":
                print(f"[ì‹œìŠ¤í…œ] ì”ê³  20ê°œ ì´ˆê³¼ ë°œê²¬! ë‹¤ìŒ í˜ì´ì§€(ì—°ì†ì¡°íšŒ)ë¥¼ ìš”ì²­í•©ë‹ˆë‹¤. (í˜„ì¬ê¹Œì§€ {len(self.held_stocks)}ì¢…ëª© ë³µì›ë¨)")
                # 0.2ì´ˆ ëŒ€ê¸° í›„ ë‹¤ìŒ í˜ì´ì§€ ìš”ì²­ (ì„œë²„ ê³¼ë¶€í•˜ ì—ëŸ¬ ë°©ì§€)
                QTimer.singleShot(200, lambda: self._req_account_balance(prev_next="2"))
            else:
                # ë§ˆì§€ë§‰ í˜ì´ì§€ê¹Œì§€ ëª¨ë‘ ì½ì–´ì˜¨ ê²½ìš°ì—ë§Œ ë‹¤ìŒ ë‹¨ê³„(ì¡°ê±´ì‹ ë¡œë”© ë° ë³´ê³ )ë¡œ ë„˜ì–´ê°‘ë‹ˆë‹¤.
                print(f"[ì‹œìŠ¤í…œ] ë³´ìœ  ì¢…ëª© ë¦¬ìŠ¤íŠ¸ ë³µì› ì™„ë£Œ: ì´ {len(self.held_stocks)}ì¢…ëª©")
    
                # [ìˆ˜ì •] ì”ê³  ë³µì› ì™„ë£Œ í›„, ë°”ë¡œ ì¡°ê±´ì‹ì„ ì¼œì§€ ì•Šê³  ì˜ˆìˆ˜ê¸ˆì„ ë¨¼ì € ì¡°íšŒí•©ë‹ˆë‹¤.
                QTimer.singleShot(200, self._req_deposit)

        elif rqname == "ì˜ˆìˆ˜ê¸ˆìš”ì²­":
            deposit_str = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, 0, "ì£¼ë¬¸ê°€ëŠ¥ê¸ˆì•¡").strip()
            self.current_deposit = int(deposit_str) if deposit_str else 0
            
            # ì¥ì™¸ ì‹œê°„(08:50~15:40 ì™¸)ì—ëŠ” ëŒ€ê¸°í•˜ë„ë¡ ë³€ê²½ (ì¡°ê±´ê²€ìƒ‰ ë¡œë”© ì§€ì—°)
            now_time_str = datetime.now().strftime('%H%M%S')
            if "085000" <= now_time_str <= "154000":
                if not self.condition_started:
                    self._print_slippage_report()
                    self.condition_started = True
                    QTimer.singleShot(200, self._get_condition_load)
            else:
                if not self.condition_started:
                    print(f"[ì‹œìŠ¤í…œ] í˜„ì¬ëŠ” ì¥ì™¸ ì‹œê°„ì…ë‹ˆë‹¤. (ì˜ˆìˆ˜ê¸ˆ: {self.current_deposit:,}ì›) 08:50ì— ìë™ìœ¼ë¡œ ì‹œì‘í•©ë‹ˆë‹¤.")

        elif rqname == "ì£¼ì‹ì¼ë´‰ê¸°ë³¸ìš”ì²­":
            cnt = self.kiwoom.dynamicCall("GetRepeatCnt(QString, QString)", trcode, rqname)

            op = 0
            pc = 0
            c_list = []

            if cnt > 0:
                open_price = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, 0,
                                                     "ì‹œê°€").strip()
                op = abs(int(open_price)) if open_price else 0

                if cnt > 1:
                    prev_close = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname,
                                                         1, "í˜„ì¬ê°€").strip()
                    pc = abs(int(prev_close)) if prev_close else 0

                for i in range(1, min(cnt, 5)):
                    close_price = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname,
                                                          i, "í˜„ì¬ê°€").strip()
                    c_list.append(abs(int(close_price)) if close_price else 0)

            self.tr_data_temp = {
                'open': op,
                'prev': pc,
                'c_list': c_list
            }
            if hasattr(self, 'tr_event_loop') and self.tr_event_loop.isRunning():
                self.tr_event_loop.quit()

    # -------------------------------------
    # ë©”ì¸ ë¡œì§
    # -------------------------------------
    def _execute_buy(self, code):
        now_time_str = datetime.now().strftime('%H%M%S')
        if not ("090000" <= now_time_str <= "152000"):
            return

        now = datetime.now().strftime('%H:%M:%S')
        stock_name = self.kiwoom.dynamicCall("GetMasterCodeName(QString)", code)

        if code in self.open_buy_orders:
            print(f"[{now}] [ë§¤ìˆ˜ìŠ¤í‚µ] {stock_name}({code}) - ë¯¸ì²´ê²° ë§¤ìˆ˜ ì£¼ë¬¸ ëŒ€ê¸° ì¤‘")
            return

        if code in self.held_stocks:
            print(f"[{now}] [ë§¤ìˆ˜ìŠ¤í‚µ] {stock_name}({code}) - ì´ë¯¸ ë³´ìœ  ì¤‘ì¸ ì¢…ëª©")
            return

        if code in self.bought_today:
            return

        if code in self.sold_today:
            print(f"[{now}] [ë§¤ìˆ˜ìŠ¤í‚µ] {stock_name}({code}) - ë‹¹ì¼ ë§¤ë„ ì¢…ëª© (ì¬ë§¤ìˆ˜ ë°©ì§€)")
            return

        now_ts = time.time()
        if code in self.buy_meta_data:
            last_ts = self.buy_meta_data[code].get('timestamp', 0)
            if now_ts - last_ts < 2.0:
                return

        # [ì‹ ê·œ] ì˜ˆìˆ˜ê¸ˆ ì‚¬ì „ ì°¨ë‹¨ ë°©ì–´ ë¡œì§ (ìµœëŒ€ë§¤ìˆ˜ê¸ˆì•¡ì˜ 130% ì´í•˜ì¼ ê²½ìš° ìŠ¤í‚µ)
        required_margin = self.MAX_BUY_AMOUNT * 1.3
        if self.current_deposit <= required_margin:
            print(f"[{now}] [ë§¤ìˆ˜ìŠ¤í‚µ] {stock_name}({code}) - ì¦ê±°ê¸ˆ ë¶€ì¡± ì‚¬ì „ ì°¨ë‹¨ (ì˜ˆìˆ˜ê¸ˆ: {int(self.current_deposit):,}ì› / í•„ìš”: {int(required_margin):,}ì›)")
            return

        # 1. ì§€ì—° ì—†ëŠ” ì¦‰ì‹œ ì£¼ë¬¸
        current_price_str = self.kiwoom.dynamicCall("GetMasterLastPrice(QString)", code)
        current_price = abs(int(current_price_str)) if current_price_str else 0

        if current_price == 0:
            print(f"[{now}] [ë§¤ìˆ˜ë¶ˆê°€] {stock_name}({code}) - í˜„ì¬ê°€ ì¡°íšŒ ë¶ˆê°€")
            return

        quantity = self.MAX_BUY_AMOUNT // current_price
        if quantity == 0:
            print(f"[{now}] [ë§¤ìˆ˜ë¶ˆê°€] {stock_name}({code}) - ë‹¨ê°€ ì´ˆê³¼")
            return

        print(f"[{now}] ğŸš€ [ìë™ë§¤ìˆ˜] {stock_name}({code}) {quantity}ì£¼ ì¦‰ì‹œ ì‹œì¥ê°€ ì£¼ë¬¸ ë°œì†¡!")
        self.buy_meta_data[code] = {'target_raw': 0, 'time': now, 'timestamp': now_ts}
        
        # [ì‹ ê·œ] ì£¼ë¬¸ ì¦‰ì‹œ ë‚´ë¶€ ì˜ˆìˆ˜ê¸ˆì„ ì°¨ê°í•˜ì—¬, 1ë¶„ ë™ê¸°í™” ì „ì— í—ˆìˆ˜ì£¼ë¬¸ì´ ë‚˜ê°€ëŠ” ê²ƒì„ ì™„ë²½ ì°¨ë‹¨
        self.current_deposit -= (quantity * current_price)
        
        self._send_order(code, 1, quantity, 0)

        # 2. ì£¼ë¬¸ í›„ ì—¬ìœ ë¡­ê²Œ ë°±í…ŒìŠ¤íŠ¸ ëª©í‘œê°€ ê³„ì‚°
        try:
            info = self._get_stock_info(code)
            open_price = info.get('open', current_price)
            prev_price = info.get('prev', current_price)
            c_list = info.get('c_list', [])

            target_price = math.ceil(prev_price * 1.05)
            
            # --- [ìˆ˜ì •] ë§¤ìˆ˜ ëª©í‘œê°€ ì‚°ì • ë¡œì§ ë³€ê²½ ---
            # ê¸°ì¡´: ì „ì¼ ì¢…ê°€ ëŒ€ë¹„ 5% ìƒìŠ¹ê°€ì™€ 3ì¼/5ì¼ì„  ê³¨ë“ í¬ë¡œìŠ¤ ê°€ê²© ì¤‘ 'ë” ë†’ì€ ê¸ˆì•¡'ì„ ì„ íƒ
            # ë³€ê²½: ê³¨ë“ í¬ë¡œìŠ¤ ì¡°ê±´ì€ ì œì™¸í•˜ê³  'ì „ì¼ ì¢…ê°€ ëŒ€ë¹„ 5% ìƒìŠ¹ê°€'ë¡œë§Œ ë§¤ìˆ˜ ëª©í‘œê°€ë¥¼ ê³ ì •
            
            # [ì¶”í›„ ë³µì›ìš© ì£¼ì„] ì•„ë˜ëŠ” ê¸°ì¡´ ê³¨ë“ í¬ë¡œìŠ¤ ê°€ê²© ê³„ì‚° ë¡œì§ì…ë‹ˆë‹¤. í•„ìš” ì‹œ ì£¼ì„ì„ í•´ì œí•˜ì„¸ìš”.
            # golden_cross_price = 0
            # if len(c_list) >= 4:
            #     c_1, c_2, c_3, c_4 = c_list[0], c_list[1], c_list[2], c_list[3]
            #     golden_cross_price = math.ceil(1.5 * (c_3 + c_4) - (c_1 + c_2))
            # buy_req_price = max(target_price, golden_cross_price)
            
            buy_req_price = target_price  # ì „ì¼ì¢…ê°€ ëŒ€ë¹„ 5% ìƒìŠ¹ê°€ë¡œ ê³ ì •
            # ----------------------------------------

            target_raw_int = int(open_price) if open_price > buy_req_price else int(buy_req_price)

            # 3. ì‚¬í›„ ë©”ëª¨ë¦¬ ì—…ë°ì´íŠ¸
            self.buy_meta_data[code]['target_raw'] = target_raw_int
            print(f"  > (ì‚¬í›„ê¸°ë¡) ë°±í…ŒìŠ¤íŠ¸ ë§¤ìˆ˜ëª©í‘œê°€ ì‚°ì¶œ ì™„ë£Œ: {target_raw_int:,}ì› (ì—‘ì…€ ë°˜ì˜ ëŒ€ê¸° ì¤‘)")

            self._update_csv_target_price(code, target_raw_int, 'BUY')

            if code in self.held_stocks:
                self.held_stocks[code]['target_raw'] = target_raw_int
                if target_raw_int > 0:
                    buy_price = self.held_stocks[code]['csv_buy_price']
                    self.held_stocks[code]['csv_slippage'] = ((buy_price - target_raw_int) / target_raw_int) * 100

        except Exception as e:
            print(f"[{now}] [ì˜¤ë¥˜] ê°€ê²©ì •ë³´ ì‚¬í›„ ì¡°íšŒ ì‹¤íŒ¨: {code} ({e})")

    def _execute_sell(self, code):
        now_time_str = datetime.now().strftime('%H%M%S')
        if not ("090000" <= now_time_str <= "153000"):
            return

        now = datetime.now().strftime('%H:%M:%S')
        stock_name = self.kiwoom.dynamicCall("GetMasterCodeName(QString)", code)

        if code in self.bought_today:
            print(f"[{now}] [ë§¤ë„ìŠ¤í‚µ] {stock_name} - ë‹¹ì¼ ë§¤ìˆ˜ ì¢…ëª©")
            return

        if code in self.held_stocks and self.held_stocks[code]['qty'] > 0:
            quantity = self.held_stocks[code]['qty']

            # 1. ì§€ì—°ì‹œê°„ 0ì´ˆ ì¦‰ì‹œ ì‹œì¥ê°€ ë§¤ë„ ë°œì†¡
            print(f"[{now}] ğŸš€ [ìë™ë§¤ë„] {stock_name} {quantity}ì£¼ ì¦‰ì‹œ ì‹œì¥ê°€ ë§¤ë„ ë°œì†¡!")
            self._send_order(code, 2, quantity, 0)

            # 2. ì£¼ë¬¸ í›„ ë°±í…ŒìŠ¤íŠ¸ ë§¤ë„ëª©í‘œê°€ ê³„ì‚°
            info = self._get_stock_info(code)
            c_list = info.get('c_list', [])
            open_price = info.get('open', 0)

            sell_target_price = 0
            if len(c_list) >= 4:
                c_1, c_2, c_3, c_4 = c_list[0], c_list[1], c_list[2], c_list[3]
                cross_price = round(1.5 * (c_3 + c_4) - (c_1 + c_2))

                if 0 < open_price < cross_price:
                    sell_target_price = open_price
                else:
                    sell_target_price = cross_price

            if sell_target_price == 0:
                current_price_str = self.kiwoom.dynamicCall("GetMasterLastPrice(QString)", code)
                sell_target_price = abs(int(current_price_str)) if current_price_str else 0

            self.held_stocks[code]['sell_target_price'] = sell_target_price
            print(f"  > (ì‚¬í›„ê¸°ë¡) ë°±í…ŒìŠ¤íŠ¸ ë§¤ë„ëª©í‘œê°€ ì‚°ì¶œ ì™„ë£Œ: {sell_target_price:,}ì› (ì—‘ì…€ ë°˜ì˜ ëŒ€ê¸° ì¤‘)")

            # 3. ì‚¬í›„ ë©”ëª¨ë¦¬ ì—…ë°ì´íŠ¸
            self._update_csv_target_price(code, sell_target_price, 'SELL')

        else:
            print(f"[{now}] [ë§¤ë„ë¶ˆê°€] {stock_name} - ì”ê³  ì—†ìŒ")

    # -------------------------------------
    # ì‘ì—… í ì²˜ë¦¬
    # -------------------------------------
    def _process_job_queue(self):
        if self.is_processing_job:
            QTimer.singleShot(200, self._process_job_queue)
            return

        if not self.job_queue:
            QTimer.singleShot(500, self._process_job_queue)
            return

        self.is_processing_job = True

        try:
            job = self.job_queue.pop(0)
            job_type = job['type']
            code = job['code']

            if job_type == 'BUY':
                self._execute_buy(code)
            elif job_type == 'SELL':
                self._execute_sell(code)
        finally:
            self.is_processing_job = False
            QTimer.singleShot(300, self._process_job_queue)

    # -------------------------------------
    # ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
    # -------------------------------------
    def comm_connect(self):
        print("[ì‹œìŠ¤í…œ] ë¡œê·¸ì¸ ì‹œë„...")
        self.kiwoom.dynamicCall("CommConnect()")
        self.login_event_loop = QEventLoop()
        self.login_event_loop.exec_()

    def _event_connect(self, err_code):
        if err_code == 0:
            print("ë¡œê·¸ì¸ ì„±ê³µ!")
            self.kiwoom.dynamicCall("KOA_Functions(QString, QString)", "SetShowMessage", "0")

            self._get_account_info()
            QTimer.singleShot(200, self._req_outstanding_orders)
        else:
            print("ë¡œê·¸ì¸ ì‹¤íŒ¨")
            self.login_event_loop.exit()

    def _handler_msg(self, scr_no, rqname, trcode, msg):
        if "ë§¤ìˆ˜" in rqname or "ì£¼ë¬¸" in msg:
            print(f"[ì„œë²„ë©”ì‹œì§€] {msg}")
        elif "ì¡°íšŒ" in msg or "ì´ˆê³¼" in msg or "ì œí•œ" in msg:
            print(f"[ì„œë²„ê²½ê³ ] {msg}")

    def after_login(self):
        self.login_event_loop.exit()

    def _get_account_info(self):
        self.account_num = self.kiwoom.dynamicCall("GetLoginInfo(QString)", "ACCNO").split(';')[0]
        print(f"[ë‚´ ì •ë³´] ê³„ì¢Œë²ˆí˜¸: {self.account_num}")

    def _get_condition_load(self):
        self.kiwoom.dynamicCall("GetConditionLoad()")

    def _handler_condition_load(self, ret, msg):
        if ret == 1:
            print("[ì‹œìŠ¤í…œ] ì¡°ê±´ì‹ ë¡œë”© ì™„ë£Œ.")
            conditions = self.kiwoom.dynamicCall("GetConditionNameList()").split(";")[:-1]
            for c in conditions:
                idx, name = c.split('^')
                if name in [self.BUY_STRATEGY_NAME, self.SELL_STRATEGY_NAME]:
                    print(f"[{name}] ì´ˆê¸° ê²€ìƒ‰ ë° ì‹¤ì‹œê°„ ê°ì‹œ ìš”ì²­...")
                    self.kiwoom.dynamicCall("SendCondition(QString, QString, int, int)",
                                            "0156" if "ë§¤ìˆ˜" in name else "0157", name, int(idx), 1)
                    self._safe_delay(1500)

    def _handler_condition(self, scr_no, code_list, cond_name, cond_index, next):
        now = datetime.now().strftime('%H:%M:%S')
        codes = code_list.split(';')[:-1] if code_list else []
        print(f"\n[{now}] [{cond_name}] ê²€ìƒ‰ ê²°ê³¼: {len(codes)}ì¢…ëª©")

        if cond_name.strip() == self.SELL_STRATEGY_NAME.strip():
            sell_targets = [c for c in codes if c in self.held_stocks]
            if sell_targets:
                print(f"  > [ë§¤ë„ëŒ€ìƒë°œê²¬] ì”ê³  ì¤‘ ë§¤ë„ ì¡°ê±´ ì¼ì¹˜: {len(sell_targets)}ì¢…ëª© ë°œê²¬ (íì— ëŒ€ê¸° ë“±ë¡)")
                for code in sell_targets:
                    self.job_queue.append({'type': 'SELL', 'code': code})
            else:
                print(f"  > [ë§¤ë„ëŒ€ìƒì—†ìŒ] ê²€ìƒ‰ëœ ì¢…ëª© ì¤‘ í˜„ì¬ ì”ê³ ì— ë³´ìœ í•œ ì¢…ëª©ì´ ì—†ìŠµë‹ˆë‹¤.")

        elif cond_name.strip() == self.BUY_STRATEGY_NAME.strip():
            for code in codes:
                self.current_conditioned_stocks.add(code)
                self.job_queue.append({'type': 'BUY', 'code': code})

    def _handler_real_condition(self, code, type, cond_name, cond_index):
        if type == 'I':
            if cond_name.strip() == self.BUY_STRATEGY_NAME.strip():
                self.current_conditioned_stocks.add(code)
                self.job_queue.append({'type': 'BUY', 'code': code})
            elif cond_name.strip() == self.SELL_STRATEGY_NAME.strip():
                self.job_queue.append({'type': 'SELL', 'code': code})
        elif type == 'D' and cond_name.strip() == self.BUY_STRATEGY_NAME.strip():
            self.current_conditioned_stocks.discard(code)

    def _send_order(self, code, order_type, quantity, price, order_no=""):
        if order_type == 1:  # ì‹ ê·œë§¤ìˆ˜
            hoga = self.BUY_ORDER_TYPE
            if hoga == "03": price = 0  # ì‹œì¥ê°€ëŠ” ê°€ê²© 0 ì „ì†¡
        elif order_type == 2:  # ì‹ ê·œë§¤ë„
            hoga = self.SELL_ORDER_TYPE
            if hoga == "03":
                price = 0
            elif hoga == "00" and price == 0:
                current_price_str = self.kiwoom.dynamicCall("GetMasterLastPrice(QString)", code)
                price = abs(int(current_price_str)) if current_price_str else 0
        else:  # ë§¤ìˆ˜ì·¨ì†Œ ë“± ê¸°íƒ€
            hoga = "00"

        self.kiwoom.dynamicCall("SendOrder(QString, QString, QString, int, QString, int, int, QString, QString)",
                                ["send_order", "0101", self.account_num, order_type, code, quantity, price, hoga,
                                 order_no])

    def _handler_chejan_data(self, gubun, item_cnt, fid_list):
        if gubun == '0':  # ì ‘ìˆ˜/ì²´ê²°
            status = self.kiwoom.dynamicCall("GetChejanData(int)", 913)
            code = self.kiwoom.dynamicCall("GetChejanData(int)", 9001).replace('A', '').strip()
            order_no = self.kiwoom.dynamicCall("GetChejanData(int)", 9203)
            order_type = self.kiwoom.dynamicCall("GetChejanData(int)", 905)

            if "ë§¤ìˆ˜" in order_type:
                if status == "ì ‘ìˆ˜":
                    self.open_buy_orders[code] = order_no
                elif status == "ì²´ê²°":
                    if code in self.open_buy_orders: del self.open_buy_orders[code]

                    if code not in self.held_stocks or 'buy_date' not in self.held_stocks[code]:
                        buy_price = int(self.kiwoom.dynamicCall("GetChejanData(int)", 910))
                        stock_name = self.kiwoom.dynamicCall("GetMasterCodeName(QString)", code)
                        today = datetime.now().strftime('%Y-%m-%d')
                        now_time = datetime.now().strftime('%H:%M:%S')

                        target_raw = 0
                        if code in self.buy_meta_data: target_raw = self.buy_meta_data[code]['target_raw']

                        slippage = 0
                        if target_raw > 0:
                            slippage = ((buy_price - target_raw) / target_raw) * 100

                        self._log_buy_trade(code, stock_name, today, now_time, target_raw, buy_price, slippage)

                        existing_qty = self.held_stocks[code].get('qty', 0) if code in self.held_stocks else 0

                        self.held_stocks[code] = {
                            'qty': existing_qty, 'price': buy_price, 'buy_date': today, 'buy_time': now_time,
                            'target_raw': target_raw, 'type': 'ì§€ì •ê°€',
                            'csv_buy_price': buy_price,
                            'csv_slippage': buy_price
                        }

                        if code not in self.bought_today:
                            self.bought_today.append(code)

            elif "ë§¤ë„" in order_type and status == "ì²´ê²°":
                actual_sell_price = int(self.kiwoom.dynamicCall("GetChejanData(int)", 910))
                stock_name = self.kiwoom.dynamicCall("GetMasterCodeName(QString)", code)
                today = datetime.now().strftime('%Y-%m-%d')
                now_time = datetime.now().strftime('%H:%M:%S')

                sell_target_price = 0
                if code in self.held_stocks and 'sell_target_price' in self.held_stocks[code]:
                    sell_target_price = self.held_stocks[code]['sell_target_price']

                if sell_target_price == 0:
                    sell_target_price = actual_sell_price

                self._log_sell_trade(code, stock_name, today, now_time, sell_target_price, actual_sell_price)

                if code not in self.sold_today:
                    self.sold_today.append(code)

                # [ì‹ ê·œ] ë§¤ë„ ì²´ê²° ì‹œ ì˜ˆìˆ˜ê¸ˆ ê°±ì‹  ìš”ì²­ (1ì´ˆ ë’¤ ì•ˆì „í•˜ê²Œ)
                QTimer.singleShot(1000, self._req_deposit)

                # [ìˆ˜ì •/ì œê±°ë¨] ì˜ˆìˆ˜ê¸ˆ í™•ë³´ ì‹œ ê¸°ì¡´ í¬ì°© ì¢…ëª©ì„ ë¬´ì‘ì • ì¶”ê²© ë§¤ìˆ˜(ì¬ê²€ìƒ‰)í•˜ëŠ” ë¡œì§ì„ ì‚­ì œí•¨.
                # (ì´ì œ ì–µì§€ë¡œ íì— ë„£ì§€ ì•Šê³ , ìƒˆë¡œìš´ ì‹¤ì‹œê°„ í¸ì… ì‹ í˜¸ê°€ ë“¤ì–´ì˜¬ ë•Œë§Œ ë§¤ìˆ˜í•¨)

            print(f"[ì²´ê²°ì•Œë¦¼] {code} | {status} | {order_no}")

        elif gubun == '1':  # ì”ê³ í†µë³´
            code = self.kiwoom.dynamicCall("GetChejanData(int)", 9001).replace('A', '').strip()
            qty = int(self.kiwoom.dynamicCall("GetChejanData(int)", 930))
            if qty > 0:
                if code in self.held_stocks:
                    self.held_stocks[code]['qty'] = qty

                    avg_price_str = self.kiwoom.dynamicCall("GetChejanData(int)", 931)
                    avg_price = abs(int(avg_price_str)) if avg_price_str else 0

                    if avg_price > 0:
                        self.held_stocks[code]['price'] = avg_price
                        self.held_stocks[code]['csv_buy_price'] = avg_price

                        if not self.history_df.empty:
                            mask = (self.history_df['ì¢…ëª©ì½”ë“œ'] == code) & (
                                        self.history_df['ë§¤ë„ì¼'].isna() | (self.history_df['ë§¤ë„ì¼'] == ''))
                            if not self.history_df.loc[mask].empty:
                                idx = self.history_df.loc[mask].index[-1]
                                self.history_df.loc[idx, 'ì‹¤ì œë§¤ì…ê°€'] = avg_price

                                target_raw = self.history_df.loc[idx, 'ë§¤ìˆ˜ëª©í‘œê°€']
                                if target_raw and str(target_raw).strip() != '' and float(target_raw) > 0:
                                    t_raw = float(target_raw)
                                    new_slippage = round(((avg_price - t_raw) / t_raw) * 100, 2)
                                    self.history_df.loc[idx, 'ë§¤ìˆ˜ìŠ¬ë¦¬í”¼ì§€(%)'] = new_slippage
                                    self.held_stocks[code]['csv_slippage'] = new_slippage

                        self.csv_save_timer.start(5000)
                else:
                    self.held_stocks[code] = {'qty': qty, 'price': 0}
            else:
                if code in self.held_stocks: del self.held_stocks[code]

    def _periodic_check(self):
        # [ì‹ ê·œ] ì˜ˆìˆ˜ê¸ˆ 1ë¶„ë§ˆë‹¤ ì£¼ê¸°ì  ì„œë²„ ë™ê¸°í™”
        self._req_deposit()
        
        # [ì‹ ê·œ] ì‹œê°„ ì²´í¬ë¥¼ í†µí•´ ì¥ ì‹œì‘ ì „/ì¥ ì¢…ë£Œ í›„ ë¶ˆí•„ìš”í•œ ì•Œë¦¼ ë° ê²€ìƒ‰ ë™ì‘ ì œí•œ
        now_time_str = datetime.now().strftime('%H%M%S')
        if "085000" <= now_time_str <= "154000":
            if not self.condition_started:
                print(f"\n[ì‹œìŠ¤í…œ] ì§€ì • ì‹œê°„ ë„ë‹¬. ì¡°ê±´ì‹ ë¡œë”© ë° ì‹¤ì‹œê°„ ê°ì‹œë¥¼ ìë™ ì‹œì‘í•©ë‹ˆë‹¤.")
                self.condition_started = True
                self._get_condition_load()
        else:
            self.condition_started = False
            return  # ì´ ì‹œê°„ ì™¸ì—ëŠ” ì£¼ê¸°ì  ì ê²€ ì•Œë¦¼ ìƒëµ

        now = datetime.now()
        print(f"\n[ì‹œìŠ¤í…œ ì ê²€] {now.strftime('%H:%M:%S')} ì‹¤ì‹œê°„ ê°ì‹œ ì‘ë™ ì¤‘...")

        search_count = len(self.current_conditioned_stocks)
        print(f"  > [ì‹¤ì‹œê°„ ê²€ìƒ‰] í˜„ì¬ ë§¤ìˆ˜ ì¡°ê±´ í¬ì°© ì¢…ëª© ìˆ˜: {search_count}ê°œ")

        overlap_held = len(self.current_conditioned_stocks.intersection(set(self.held_stocks.keys())))
        overlap_order = len(self.current_conditioned_stocks.intersection(set(self.open_buy_orders.keys())))

        print(f"  > [ê³„ì¢Œ í˜„í™©] ë³´ìœ ì¢…ëª©: {len(self.held_stocks)}ê°œ, ë¯¸ì²´ê²°ì£¼ë¬¸: {len(self.open_buy_orders)}ê±´")

        if self.job_queue:
            print(f"  > [ëŒ€ê¸° ì‘ì—…] í˜„ì¬ íì—ì„œ {len(self.job_queue)}ê°œì˜ ë§¤ìˆ˜/ë§¤ë„ ì‘ì—…ì´ ìˆœì°¨ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤.")

        if now.hour == 15 and now.minute >= 20 and self.open_buy_orders:
            print("[ì¥ë§ˆê°] ë¯¸ì²´ê²° ì·¨ì†Œ")
            for code, order_no in list(self.open_buy_orders.items()):
                self._send_order(code, 3, 0, 0, order_no)
                del self.open_buy_orders[code]
                self._safe_delay(300)

    def _print_slippage_report(self):
        # [ì‹ ê·œ] ì¥ì™¸ ì‹œê°„ì—ëŠ” ìŠ¬ë¦¬í”¼ì§€ ë¶„ì„í‘œ ì¶œë ¥ ìƒëµ
        now_time_str = datetime.now().strftime('%H%M%S')
        if not ("085000" <= now_time_str <= "154000"):
            return

        if not self.held_stocks: return
        print(f"\n[ì‹œìŠ¤í…œ] ìŠ¬ë¦¬í”¼ì§€ ë¶„ì„ ({datetime.now().strftime('%H:%M:%S')})")
        print("-" * 100)
        print(f"{'ì¢…ëª©ëª…':<10} | {'ë§¤ìˆ˜ì¼ì‹œ':<20} | {'ëª©í‘œê°€':<10} | {'ë§¤ì…ê°€':<10} | {'ìŠ¬ë¦¬í”¼ì§€%':<10}")
        print("-" * 100)

        total_slippage = 0
        count = 0

        for code, info in self.held_stocks.items():
            name = self.kiwoom.dynamicCall("GetMasterCodeName(QString)", code)
            target = info.get('target_raw', 0)

            buy_price = info.get('csv_buy_price', info['price'])
            slippage = info.get('csv_slippage', 0.0)

            total_slippage += slippage
            count += 1

            print(
                f"{name:<10} | {info.get('buy_date', '')} {info.get('buy_time', '')} | {int(target):<10} | {int(buy_price):<10} | {slippage:.2f}%")

        print("-" * 100)
        if count > 0:
            avg_slippage = total_slippage / count
            print(f"[ì „ì²´ í‰ê·  ìŠ¬ë¦¬í”¼ì§€] {avg_slippage:.2f}%")
        print("-" * 100)
