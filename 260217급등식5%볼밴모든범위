# ==========================================
# ğŸ“Š [ìµœì¢… ì‹œë‚˜ë¦¬ì˜¤ë³„ ì„±ê³¼ ë¹„êµ]
# ================================================================================
# êµ¬ê°„ (Bandwidth)  |     ì²´ê²° ì¢…ëª©ìˆ˜ |     ì´ ë§¤ë§¤íšŸìˆ˜ |      ì „ì²´ ìŠ¹ë¥  |              ì´ ìˆ˜ìµê¸ˆ
# --------------------------------------------------------------------------------
# 6% ë¯¸ë§Œ           |         40ê°œ |        207íšŒ |      35.3% |        -15,495,624ì›
# 6% ~ 8%         |         41ê°œ |        251íšŒ |      37.8% |         36,766,145ì›
# 8% ~ 10%        |         41ê°œ |        238íšŒ |      36.6% |        -10,354,036ì›
# 10% ~ 12%       |         45ê°œ |        242íšŒ |      35.1% |         -5,496,967ì›
# 12% ~ 14%       |         41ê°œ |        237íšŒ |      44.3% |         44,416,428ì›
# 14% ì´ìƒ          |         49ê°œ |        934íšŒ |      40.5% |         30,546,684ì›
# ================================================================================
import matplotlib

# í™”ë©´ í‘œì‹œ ì—†ì´ ë‚´ë¶€ì—ì„œ ì´ë¯¸ì§€ ìƒì„± (ì¶©ëŒ ë°©ì§€)
matplotlib.use('Agg')

import backtrader as bt
import pandas as pd
import os
import math
from datetime import time, timedelta
from collections import defaultdict
import matplotlib.pyplot as plt


# ==========================================
# [ì „ëµ] ì¼ë´‰ ê¸‰ë“±ì£¼ ëŒíŒŒ + ë°´ë“œí­ êµ¬ê°„ í•„í„° + ì •ë°€ ë§¤ë„
# ==========================================
class CustomDailyStrategy(bt.Strategy):
    """
    [ìƒì„¸ ì „ëµ ì„¤ëª…]
    ================================================================================
    1. ë§¤ìˆ˜ ì§„ì… ì¡°ê±´ (ëª¨ë‘ ë§Œì¡± ì‹œ)
       A. [ë³€ë™ì„± ëŒíŒŒ]
          - 'ì „ì¼ ì¢…ê°€ + 5% ê°€ê²©'ì„ ëŒíŒŒí•  ë•Œ ì§„ì….
          - ê°­ìƒìŠ¹ìœ¼ë¡œ ì´ë¯¸ í•´ë‹¹ ê°€ê²©ì„ ë„˜ì–´ì„œ ì‹œì‘í•˜ë©´ ì‹œê°€ì— ì§„ì….
       B. [ìœ ë™ì„±] ë‹¹ì¼ ê±°ë˜ëŒ€ê¸ˆ 50ì–µ ì› ì´ìƒ.
       C. [ì¶”ì„¸] 1ë´‰ì „(ì „ì¼) ë° 0ë´‰ì „(ë‹¹ì¼) ê¸°ì¤€ 3ì¼ ì´ë™í‰ê· ì„  > 5ì¼ ì´ë™í‰ê· ì„  (ì§€ì† ì •ë°°ì—´ í™•ì¸).
       D. [ìˆ˜ë ´] ì „ì¼(D-1) ê¸°ì¤€ ë³¼ë¦°ì €ë°´ë“œ(10, 2) ë°´ë“œí­ì´ ì„¤ì •ëœ êµ¬ê°„(Min ~ Max) ë‚´ì— ìœ„ì¹˜.

    2. ë§¤ë„ ì²­ì‚° ì¡°ê±´
       - 3ì¼ì„ ê³¼ 5ì¼ì„ ì´ ì—­ë°°ì—´(ë°ë“œí¬ë¡œìŠ¤)ë˜ë©´ ë¬´ì¡°ê±´ ë§¤ë„.
       - Case A (ì´ë¯¸ ì—­ë°°ì—´): ì „ì¼ ì¢…ê°€ ê¸°ì¤€ ì´ë¯¸ ì—­ë°°ì—´ì´ë©´ ì‹œê°€ì— ì¦‰ì‹œ ì²­ì‚°.
       - Case B (ì¥ì¤‘ ì—­ë°°ì—´): ì¥ì¤‘ ë°ë“œí¬ë¡œìŠ¤ê°€ ë°œìƒí•˜ëŠ” **ì •í™•í•œ êµì°¨ ê°€ê²©**ì„ ê³„ì‚°í•˜ì—¬ ì¦‰ì‹œ ì²­ì‚°.
    ================================================================================
    """
    params = (
        ('target_pct', 0.05),  # 5%
        ('ma_fast', 3),  # 3ì¼
        ('ma_slow', 5),  # 5ì¼
        ('boll_period', 10),  # ë³¼ë¦°ì €ë°´ë“œ ê¸°ê°„
        ('boll_dev', 2.0),  # ë³¼ë¦°ì €ë°´ë“œ ìŠ¹ìˆ˜
        ('bandwidth_min', 0.06),  # ë°´ë“œí­ ìµœì†Œê°’ (ê¸°ë³¸ê°’)
        ('bandwidth_max', 0.08),  # ë°´ë“œí­ ìµœëŒ€ê°’ (ê¸°ë³¸ê°’)
        ('debug', False),  # ë””ë²„ê·¸ ëª¨ë“œ
    )

    def __init__(self):
        self.ma3 = bt.indicators.SimpleMovingAverage(self.data.close, period=self.p.ma_fast)
        self.ma5 = bt.indicators.SimpleMovingAverage(self.data.close, period=self.p.ma_slow)

        # ë³¼ë¦°ì €ë°´ë“œ ì§€í‘œ
        typical_price = (self.data.high + self.data.low + self.data.close) / 3.0
        self.bband = bt.indicators.BollingerBands(typical_price, period=self.p.boll_period, devfactor=self.p.boll_dev)

        self.order = None
        self.trades_history = []

        # ì°¨íŠ¸ í‘œê¸°ë¥¼ ìœ„í•œ ë§¤ìˆ˜/ë§¤ë„ ì§€ì  ì €ì¥ì†Œ (ë‚ ì§œ, ê°€ê²©)
        self.buy_points = []
        self.sell_points = []

        # ìˆ˜ìµë¥  ê³„ì‚°ì„ ìœ„í•œ ë§¤ìˆ˜ ìˆ˜ëŸ‰ ë° ë‚ ì§œ ì €ì¥
        self.buy_size = 0
        self.entry_date = None

    def log(self, txt, dt=None):
        """ë””ë²„ê¹…ìš© ë¡œê·¸ ì¶œë ¥ í•¨ìˆ˜"""
        if self.p.debug:
            dt = dt or self.data.datetime.date(0)
            print(f'[{dt.isoformat()}] {txt}')

    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            return

        if order.status in [order.Completed]:
            dt = bt.num2date(order.executed.dt).date()
            price = order.executed.price

            if order.isbuy():
                self.log(
                    f'BUY EXECUTED, Price: {price:,.2f}, Cost: {order.executed.value:,.2f}, Comm: {order.executed.comm:,.2f}')
                self.buy_points.append((dt, price))
                self.buy_size = order.executed.size  # ìˆ˜ëŸ‰ ì €ì¥
                self.entry_date = dt  # ë§¤ìˆ˜ì¼ ì €ì¥
            elif order.issell():
                self.log(
                    f'SELL EXECUTED, Price: {price:,.2f}, Cost: {order.executed.value:,.2f}, Comm: {order.executed.comm:,.2f}')
                self.sell_points.append((dt, price))

            self.bar_executed = len(self)

        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            self.log('Order Canceled/Margin/Rejected')

        # ì£¼ë¬¸ ì²˜ë¦¬ ì™„ë£Œ í›„ ì´ˆê¸°í™”
        self.order = None

    def notify_trade(self, trade):
        if not trade.isclosed: return

        # Backtrader ë‚´ë¶€ PnL ì‚¬ìš©
        pnl = trade.pnl

        entry_price = trade.price  # ì§„ì… ê°€ê²© (í‰ê· )

        # ì²­ì‚° ê°€ê²© ì¶”ì 
        if self.sell_points:
            exit_price = self.sell_points[-1][1]
        else:
            exit_price = entry_price + (pnl / self.buy_size) if self.buy_size != 0 else entry_price

        profit_pct = 0
        if entry_price > 0:
            profit_pct = ((exit_price - entry_price) / entry_price) * 100

        open_date = bt.num2date(trade.dtopen).date()
        close_date = bt.num2date(trade.dtclose).date()

        self.log(f'OPERATION PROFIT, GROSS {pnl:,.2f}, NET {pnl:,.2f}')

        self.trades_history.append({
            'open_date': open_date,
            'date': close_date,
            'profit_pct': profit_pct,
            'pnl': pnl,
            'is_win': pnl > 0,
            'entry_price': entry_price,
            'exit_price': exit_price,
            'status': 'Closed'  # ì²­ì‚° ì™„ë£Œ
        })

        # ì²­ì‚° ì™„ë£Œ ì‹œ ë§¤ìˆ˜ì¼ ì´ˆê¸°í™”
        self.entry_date = None

    def stop(self):
        if self.position:
            current_price = self.data.close[0]
            entry_price = self.position.price

            # ì €ì¥ëœ ë§¤ìˆ˜ì¼ ì‚¬ìš© (ì—†ìœ¼ë©´ Unknown)
            open_date = self.entry_date if self.entry_date else "Unknown"

            pnl = 0
            pct = 0
            if entry_price > 0:
                pnl = (current_price - entry_price) * abs(self.position.size)
                pct = ((current_price - entry_price) / entry_price) * 100

            self.trades_history.append({
                'open_date': open_date,
                'date': self.data.datetime.date(0),
                'profit_pct': pct,
                'pnl': pnl,
                'is_win': pnl > 0,
                'entry_price': entry_price,
                'exit_price': current_price,
                'status': 'Holding'  # ë³´ìœ  ì¤‘
            })

    def next(self):
        # ë¯¸ì²´ê²° ì£¼ë¬¸(ì¢€ë¹„ ì£¼ë¬¸)ì´ ë‚¨ì•„ìˆë‹¤ë©´ ì¦‰ì‹œ ì·¨ì†Œí•˜ì—¬ ì˜¤ë¥˜ ë°©ì§€
        if self.order:
            self.cancel(self.order)
            return

        if self.data.close[0] == 0: return

        # ----------------------------------------
        # [ë§¤ë„ ë¡œì§] 3ì¼ì„ -5ì¼ì„  ì—­ë°°ì—´ ë§¤ë„
        # ----------------------------------------
        if self.position:
            # 1. [ì•ˆì „ì¥ì¹˜] ì „ì¼ ì¢…ê°€ ê¸°ì¤€ ì´ë¯¸ ì—­ë°°ì—´ì´ë©´ ì¦‰ì‹œ ì‹œì¥ê°€ ë§¤ë„
            if self.ma3[-1] < self.ma5[-1]:
                self.log(f'SELL Signal (Already Crossed): Prev MA3 < Prev MA5. Market Sell.')
                self.order = self.sell(size=self.position.size, exectype=bt.Order.Market)
                return

            # 2. [ì •ë°€ ë§¤ë„] ì¥ì¤‘ ë°ë“œí¬ë¡œìŠ¤ í¬ì°©
            try:
                c1 = self.data.close[-1]
                c2 = self.data.close[-2]
                c3 = self.data.close[-3]
                c4 = self.data.close[-4]

                # êµì°¨ ê°€ê²© ì—­ì‚°
                cross_price = 1.5 * (c3 + c4) - (c1 + c2)

                # ì˜¤ëŠ˜ ì €ê°€ê°€ êµì°¨ ê°€ê²© ì´í•˜ë¡œ ë–¨ì–´ì§€ë©´ ë°ë“œí¬ë¡œìŠ¤ ë°œìƒ
                if self.data.low[0] <= cross_price:
                    if self.data.open[0] < cross_price:
                        # ê°­í•˜ë½ìœ¼ë¡œ ì‹œê°€ê°€ êµì°¨ê°€ë³´ë‹¤ ë‚®ìœ¼ë©´ ì‹œê°€ ë§¤ë„ (ì‹œì¥ê°€ ì²˜ë¦¬)
                        exec_price = self.data.open[0]
                        self.log(f'SELL Signal (Gap Down): Open {self.data.open[0]} < Cross {cross_price:.2f}')
                        self.order = self.sell(size=self.position.size, exectype=bt.Order.Market)
                    else:
                        # ì¥ì¤‘ í„°ì¹˜ ì‹œ í•´ë‹¹ ê°€ê²© ë§¤ë„
                        exec_price = cross_price
                        self.log(f'SELL Signal (Touch): Cross Price {cross_price:.2f} touched')
                        self.order = self.sell(size=self.position.size, price=exec_price, exectype=bt.Order.Limit)
                    return
            except IndexError:
                pass
            return

        # ----------------------------------------
        # [ë§¤ìˆ˜ ë¡œì§]
        # ----------------------------------------
        if not self.position:
            prev_close = self.data.close[-1]
            if prev_close <= 0: return

            # [ì¡°ê±´ D] ë³¼ë¦°ì € ë°´ë“œ í­ í™•ì¸ (ì „ì¼ ê¸°ì¤€)
            top_prev = self.bband.lines.top[-1]
            bot_prev = self.bband.lines.bot[-1]
            mid_prev = self.bband.lines.mid[-1]

            if mid_prev <= 0: return

            # ë°´ë“œí­ ê³„ì‚° (ì „ì¼)
            bandwidth = (top_prev - bot_prev) / mid_prev

            # [ìˆ˜ì •] ë°´ë“œí­ ë²”ìœ„ ì¡°ê±´ (Min <= Bandwidth < Max)
            if not (self.p.bandwidth_min <= bandwidth < self.p.bandwidth_max):
                return

            # [ê°€ê²©] ì „ì¼ ì¢…ê°€ ëŒ€ë¹„ 5% ìƒìŠ¹ ê°€ê²©
            target_price = prev_close * (1 + self.p.target_pct)

            # [ìµœì¢… ì§„ì… íŠ¸ë¦¬ê±°]
            entry_trigger_price = target_price

            # [ì¡°ê±´ B] ê±°ë˜ëŒ€ê¸ˆ 50ì–µ
            trade_amount = self.data.close[0] * self.data.volume[0]
            if trade_amount < 5000000000:
                return

            # [ì¡°ê±´ C] ì •ë°°ì—´ (ì „ì¼ ë° ë‹¹ì¼ ê¸°ì¤€)
            if self.ma3[-1] <= self.ma5[-1] or self.ma3[0] <= self.ma5[0]:
                return

            # ê³ ê°€ê°€ íŠ¸ë¦¬ê±° ê°€ê²©ë³´ë‹¤ ë‚®ìœ¼ë©´ ì§„ì… ë¶ˆê°€
            if self.data.high[0] < entry_trigger_price:
                return

            # ì‹¤ì œ ì²´ê²° ê°€ê²© ì„¤ì •
            actual_buy_price = max(self.data.open[0], entry_trigger_price)

            # [ì¤‘ìš”] ë¹„ì •ìƒì  ê°€ê²©(0ì›, ë™ì „ì£¼) ë°©ì§€
            if actual_buy_price < 100: return

            # ì§„ì… ì‹¤í–‰
            cash = self.broker.getcash()
            bet_amount = 10000000

            if cash >= bet_amount:
                size = math.floor(bet_amount / actual_buy_price)
                if size > 0:
                    self.log(f'BUY CREATE: Price {actual_buy_price:.2f} (Trigger: {entry_trigger_price:.2f})')
                    self.order = self.buy(size=size, price=actual_buy_price, exectype=bt.Order.Limit,
                                          valid=timedelta(days=1))


# ==========================================
# ì‹¤í–‰ í•¨ìˆ˜ (ë‹¨ì¼ êµ¬ê°„)
# ==========================================
def run_single_backtest(file_path, target_pct, bandwidth_min, bandwidth_max):
    try:
        df = pd.read_excel(file_path)
        rename_map = {'í˜„ì¬ê°€': 'Close', 'ì¢…ê°€': 'Close', 'ì‹œê°€': 'Open', 'ê³ ê°€': 'High', 'ì €ê°€': 'Low', 'ê±°ë˜ëŸ‰': 'Volume',
                      'ì¼ì': 'Date'}
        df = df.rename(columns=rename_map)

        cols_to_numeric = ['Close', 'Open', 'High', 'Low', 'Volume']
        for col in cols_to_numeric:
            if col in df.columns:
                if df[col].dtype == 'object':
                    df[col] = df[col].astype(str).str.replace(',', '')
                df[col] = pd.to_numeric(df[col], errors='coerce').abs()

        df = df.dropna(subset=[c for c in cols_to_numeric if c in df.columns])

        if 'Date' in df.columns:
            if df['Date'].dtype == 'object':
                df['Date'] = pd.to_datetime(df['Date'])
            df = df.sort_values('Date').set_index('Date')
        else:
            return None

        if len(df) < 30:
            return None

        cerebro = bt.Cerebro(runonce=False)
        cerebro.broker.set_coc(True)

        # [ìˆ˜ì •] ë°´ë“œí­ ë²”ìœ„ íŒŒë¼ë¯¸í„° ì „ë‹¬
        cerebro.addstrategy(CustomDailyStrategy, target_pct=target_pct,
                            bandwidth_min=bandwidth_min, bandwidth_max=bandwidth_max)

        cerebro.adddata(bt.feeds.PandasData(dataname=df))
        cerebro.broker.setcash(100000000)
        cerebro.broker.setcommission(commission=0.00015)

        strats = cerebro.run()

        trades_hist = strats[0].trades_history
        if not trades_hist:
            return {'trades': 0, 'wins': 0, 'win_rate': 0, 'profit_rate': 0, 'total_profit': 0, 'history': []}

        total_trades = len(trades_hist)
        wins = sum(1 for t in trades_hist if t['is_win'])
        win_rate = (wins / total_trades * 100) if total_trades > 0 else 0

        total_profit = sum(t['pnl'] for t in trades_hist)
        total_profit_rate = sum(t['profit_pct'] for t in trades_hist)

        return {
            'trades': total_trades,
            'wins': wins,
            'win_rate': win_rate,
            'profit_rate': total_profit_rate,
            'total_profit': total_profit,
            'history': trades_hist
        }

    except Exception as e:
        return None


# ==========================================
# ì¢…ëª© ì°¨íŠ¸ ë° ìƒì„¸ ë¶„ì„ ìƒì„±
# ==========================================
def generate_stock_chart(file_path, stock_name, target_pct, bandwidth_min, bandwidth_max, title_prefix="ğŸ¨ ì¢…ëª©"):
    try:
        print(f"\n{title_prefix} [{stock_name}] ìƒì„¸ ë¶„ì„ (BW: {int(bandwidth_min * 100)}~{int(bandwidth_max * 100)}%)")

        df = pd.read_excel(file_path)
        rename_map = {'í˜„ì¬ê°€': 'Close', 'ì¢…ê°€': 'Close', 'ì‹œê°€': 'Open', 'ê³ ê°€': 'High', 'ì €ê°€': 'Low', 'ê±°ë˜ëŸ‰': 'Volume',
                      'ì¼ì': 'Date'}
        df = df.rename(columns=rename_map)

        cols_to_numeric = ['Close', 'Open', 'High', 'Low', 'Volume']
        for col in cols_to_numeric:
            if col in df.columns:
                if df[col].dtype == 'object':
                    df[col] = df[col].astype(str).str.replace(',', '')
                df[col] = pd.to_numeric(df[col], errors='coerce').abs()

        df = df.dropna(subset=[c for c in cols_to_numeric if c in df.columns])

        if df['Date'].dtype == 'object':
            df['Date'] = pd.to_datetime(df['Date'])
        df = df.sort_values('Date').set_index('Date')

        cerebro = bt.Cerebro(runonce=False)
        cerebro.broker.set_coc(True)

        cerebro.addstrategy(CustomDailyStrategy, target_pct=target_pct,
                            bandwidth_min=bandwidth_min, bandwidth_max=bandwidth_max, debug=False)
        cerebro.adddata(bt.feeds.PandasData(dataname=df))
        cerebro.broker.setcash(100000000)
        cerebro.broker.setcommission(commission=0.00015)

        strats = cerebro.run()
        strat = strats[0]

        print(f"\nğŸ“œ [{stock_name}] ë§¤ë§¤ ìƒì„¸ ì¼ì§€")
        print("-" * 92)
        print(
            f"{'ë§¤ìˆ˜ì¼':<12} | {'ë§¤ë„ì¼':<12} | {'êµ¬ë¶„':<4} | {'ë§¤ìˆ˜ê°€':>10} | {'ë§¤ë„ê°€':>10} | {'ìˆ˜ìµê¸ˆ':>12} | {'ìˆ˜ìµë¥ ':>7} | {'ìƒíƒœ':<5}")
        print("-" * 92)

        trades_hist = strat.trades_history
        total_pnl = 0

        for t in trades_hist:
            if isinstance(t['date'], str):
                close_date_str = t['date']
            else:
                close_date_str = t['date'].strftime('%Y-%m-%d')

            if isinstance(t.get('open_date'), str):
                open_date_str = t.get('open_date', '-')
            elif t.get('open_date'):
                open_date_str = t['open_date'].strftime('%Y-%m-%d')
            else:
                open_date_str = "-"

            pnl = t['pnl']
            pct = t['profit_pct']
            mark = "ğŸ”ºìµì ˆ" if pnl > 0 else "ğŸ”¹ì†ì ˆ"
            entry = t['entry_price']
            exit_p = t['exit_price']
            status = t.get('status', 'Closed')

            print(
                f"{open_date_str:<12} | {close_date_str:<12} | {mark:<4} | {entry:10,.0f} | {exit_p:10,.0f} | {pnl:>11,.0f}ì› | {pct:>6.2f}% | {status:<5}")
            total_pnl += pnl

        print("-" * 92)
        print(f"ğŸ’° ì´ ëˆ„ì  ìˆ˜ìµ: {total_pnl:,.0f}ì›")

        plot_filename = f'chart_{stock_name}_{int(bandwidth_min * 100)}_{int(bandwidth_max * 100)}.png'
        print(f"\nğŸ“¸ ì°¨íŠ¸ ì´ë¯¸ì§€ë¥¼ ì €ì¥ ì¤‘ì…ë‹ˆë‹¤... ({plot_filename})")

        figs = cerebro.plot(style='candlestick', barup='red', bardown='blue', volume=True)
        fig = figs[0][0]
        ax = fig.get_axes()[0]

        data_dates = [bt.num2date(x).date() for x in strat.data.datetime.array]
        date_to_idx = {d: i for i, d in enumerate(data_dates)}

        for dt, price in strat.buy_points:
            if dt in date_to_idx:
                idx = date_to_idx[dt]
                ax.annotate(f'{price:,.0f}', xy=(idx, price), xytext=(0, -20),
                            textcoords='offset points',
                            arrowprops=dict(facecolor='blue', shrink=0.05, width=1, headwidth=5),
                            fontsize=8, color='blue', fontweight='bold', ha='center')

        for dt, price in strat.sell_points:
            if dt in date_to_idx:
                idx = date_to_idx[dt]
                ax.annotate(f'{price:,.0f}', xy=(idx, price), xytext=(0, 20),
                            textcoords='offset points',
                            arrowprops=dict(facecolor='red', shrink=0.05, width=1, headwidth=5),
                            fontsize=8, color='red', fontweight='bold', ha='center')

        fig.savefig(plot_filename, dpi=150)
        print(f"âœ… ì°¨íŠ¸ ì €ì¥ ì™„ë£Œ! '{plot_filename}'")

    except Exception as e:
        print(f"âŒ ì°¨íŠ¸ ìƒì„± ì‹¤íŒ¨: {e}")


def main():
    print(CustomDailyStrategy.__doc__)
    print("=== ğŸ¯ [ì¼ë´‰ ì „ëµ] ë°´ë“œí­ êµ¬ê°„ë³„ ìˆ˜ìµë¥  ë¹„êµ ë¶„ì„ (ë³´ìœ ë¶„ í¬í•¨) ===")

    data_dir = "stock_data_51"
    if not os.path.exists(data_dir):
        print(f"ğŸš¨ '{data_dir}' í´ë”ê°€ ì—†ìŠµë‹ˆë‹¤!")
        return

    files = [os.path.join(data_dir, f) for f in os.listdir(data_dir) if f.endswith(".xlsx")]
    print(f"ğŸ“‚ ë¶„ì„ ëŒ€ìƒ: {len(files)}ê°œ ì¢…ëª©\n")

    target_pct = 0.05

    # 6ê°€ì§€ ë°´ë“œí­ ì‹œë‚˜ë¦¬ì˜¤ ì •ì˜ (ìˆ˜ì •ë¨)
    scenarios = [
        {'label': '6% ë¯¸ë§Œ', 'min': 0.0, 'max': 0.06},
        {'label': '6% ~ 8%', 'min': 0.06, 'max': 0.08},
        {'label': '8% ~ 10%', 'min': 0.08, 'max': 0.10},
        {'label': '10% ~ 12%', 'min': 0.10, 'max': 0.12},
        {'label': '12% ~ 14%', 'min': 0.12, 'max': 0.14},
        {'label': '14% ì´ìƒ', 'min': 0.14, 'max': 100.0},
    ]

    scenario_results = []

    # ê° ì‹œë‚˜ë¦¬ì˜¤ë³„ ì‹¤í–‰
    for sc in scenarios:
        print(f"\nğŸš€ ì‹œë‚˜ë¦¬ì˜¤ ì‹¤í–‰: ë°´ë“œí­ {sc['label']}")
        print(f"{'ì¢…ëª©ëª…':<15} | {'ê²Œì„ìˆ˜':>5} | {'ìŠ¹ë¥ ':>6} | {'ì´ ìˆ˜ìµë¥ ':>10} | {'ì´ ìˆ˜ìµê¸ˆ':>12}")
        print("-" * 80)

        total_stats = {'trades': 0, 'profit': 0, 'wins': 0}
        best_stock = {'profit': -99999999999, 'name': '', 'file': ''}
        worst_stock = {'profit': 99999999999, 'name': '', 'file': ''}

        active_stocks = 0

        for file_path in files:
            stock_name = os.path.basename(file_path).split('_')[-1].replace('.xlsx', '')

            # íŒŒë¼ë¯¸í„° ì „ë‹¬: min, max ëŒ€ì—­í­
            res = run_single_backtest(file_path, target_pct, sc['min'], sc['max'])

            if res and res['trades'] > 0:
                active_stocks += 1
                total_stats['trades'] += res['trades']
                total_stats['profit'] += res['total_profit']
                total_stats['wins'] += res['wins']

                mark = "ğŸ”´" if res['total_profit'] > 0 else "ğŸ”µ"
                print(
                    f"{stock_name:<15} | {res['trades']:5d}íšŒ | {res['win_rate']:5.1f}% | {res['profit_rate']:9.2f}% | {res['total_profit']:11,.0f}ì› {mark}")

                if res['total_profit'] > best_stock['profit']:
                    best_stock = {'profit': res['total_profit'], 'name': stock_name, 'file': file_path}
                if res['total_profit'] < worst_stock['profit']:
                    worst_stock = {'profit': res['total_profit'], 'name': stock_name, 'file': file_path}

        print("-" * 80)
        avg_win_rate = (total_stats['wins'] / total_stats['trades'] * 100) if total_stats['trades'] > 0 else 0

        # ì‹œë‚˜ë¦¬ì˜¤ ê²°ê³¼ ì €ì¥
        scenario_results.append({
            'label': sc['label'],
            'trades': total_stats['trades'],
            'win_rate': avg_win_rate,
            'total_profit': total_stats['profit'],
            'active_stocks': active_stocks,
            'best_stock': best_stock,
            'worst_stock': worst_stock
        })

    # ìµœì¢… ë¹„êµ ë¦¬í¬íŠ¸ ì¶œë ¥
    print("\n\nğŸ“Š [ìµœì¢… ì‹œë‚˜ë¦¬ì˜¤ë³„ ì„±ê³¼ ë¹„êµ]")
    print("=" * 80)
    print(f"{'êµ¬ê°„ (Bandwidth)':<15} | {'ì²´ê²° ì¢…ëª©ìˆ˜':>10} | {'ì´ ë§¤ë§¤íšŸìˆ˜':>10} | {'ì „ì²´ ìŠ¹ë¥ ':>10} | {'ì´ ìˆ˜ìµê¸ˆ':>18}")
    print("-" * 80)

    for res in scenario_results:
        print(
            f"{res['label']:<15} | {res['active_stocks']:10d}ê°œ | {res['trades']:10d}íšŒ | {res['win_rate']:9.1f}% | {res['total_profit']:18,.0f}ì›")
    print("=" * 80)


if __name__ == "__main__":
    main()
