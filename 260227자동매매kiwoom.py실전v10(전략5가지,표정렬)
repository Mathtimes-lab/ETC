import sys
import time
import os
import math
import pandas as pd  # ë°ì´í„° ì €ì¥/ìˆ˜ì •ìš©
import numpy as np  # ë‚ ì§œ ê³„ì‚°ìš©
from datetime import datetime
from PyQt5.QtWidgets import *
from PyQt5.QAxContainer import *
from PyQt5.QtCore import *
import unicodedata

# --- [ì‹ ê·œ] ìœˆë„ìš° ì½˜ì†” 'ë¹ ë¥¸ í¸ì§‘ ëª¨ë“œ' ê°•ì œ ë¹„í™œì„±í™” (í”„ë¦¬ì§• ë°©ì§€) ---
import ctypes

try:
    kernel32 = ctypes.windll.kernel32
    h_stdin = kernel32.GetStdHandle(-10)
    mode = ctypes.c_uint32()
    kernel32.GetConsoleMode(h_stdin, ctypes.byref(mode))
    ENABLE_QUICK_EDIT_MODE = 0x0040
    mode.value &= ~ENABLE_QUICK_EDIT_MODE
    kernel32.SetConsoleMode(h_stdin, mode.value)
    print("[ì‹œìŠ¤í…œ] ì½˜ì†” 'ë¹ ë¥¸ í¸ì§‘ ëª¨ë“œ' ë¹„í™œì„±í™” ì™„ë£Œ (ë§ˆìš°ìŠ¤ í´ë¦­ ë©ˆì¶¤ ë°©ì§€)")
except Exception as e:
    print(f"[ê²½ê³ ] ì½˜ì†” ëª¨ë“œ ë³€ê²½ ì‹¤íŒ¨ (ê¸°ëŠ¥ ë™ì‘ì—ëŠ” ë¬¸ì œ ì—†ìŒ): {e}")
# -------------------------------------------------------------------

# --- [ì‹ ê·œ] ëª¨ë“  ì½˜ì†” ì¶œë ¥ì„ í…ìŠ¤íŠ¸ íŒŒì¼ë¡œ ë™ì‹œ ëˆ„ì  ì €ì¥ (ì¼ë³„ ë¡œê·¸) ---
class DualLogger:
    def __init__(self):
        self.terminal = sys.stdout

    def write(self, message):
        self.terminal.write(message)
        today_str = datetime.now().strftime("%y%m%d")
        filename = f"{today_str}.txt"
        try:
            with open(filename, "a", encoding="utf-8") as f:
                f.write(message)
        except Exception:
            pass

    def flush(self):
        self.terminal.flush()

sys.stdout = DualLogger()
# -------------------------------------------------------------------

class Kiwoom(QMainWindow):
    def __init__(self):
        super().__init__()

        # =====================================================================
        # [ì‹ ê·œ] ë‹¤ì¤‘ ì „ëµ (1~5) ê°œë³„ ì„¸íŒ… êµ¬ê°„
        # active: 1(ì‚¬ìš©í•¨), 0(ì‚¬ìš©ì•ˆí•¨)
        # buy_type / sell_type: "00"(ì§€ì •ê°€), "03"(ì‹œì¥ê°€)
        # â€» ë§¤ë„ì‹ì„ ê³µí†µìœ¼ë¡œ ì¨ë„ ì¶œì²˜(ì „ëµ)ë¥¼ ì¶”ì í•˜ì—¬ ê¼¬ì´ì§€ ì•Šê²Œ ë…ë¦½ ì‹¤í–‰ë©ë‹ˆë‹¤.
        # =====================================================================
        self.STRATEGIES = {
            "ì „ëµ1": {
                "active": 1,
                "buy_name": "260218ê¸‰ë“±ê¸°ë³¸",
                "sell_name": "260218ë§¤ë„ì‹",
                "max_buy": 500000,
                "buy_type": "03",
                "sell_type": "03"
            },
            "ì „ëµ2": {
                "active": 0,
                "buy_name": "",
                "sell_name": "",
                "max_buy": 500000,
                "buy_type": "03",
                "sell_type": "03"
            },
            "ì „ëµ3": {
                "active": 0,
                "buy_name": "",
                "sell_name": "",
                "max_buy": 500000,
                "buy_type": "03",
                "sell_type": "03"
            },
            "ì „ëµ4": {
                "active": 0,
                "buy_name": "",
                "sell_name": "",
                "max_buy": 500000,
                "buy_type": "03",
                "sell_type": "03"
            },
            "ì „ëµ5": {
                "active": 0,
                "buy_name": "",
                "sell_name": "",
                "max_buy": 500000,
                "buy_type": "03",
                "sell_type": "03"
            }
        }

        # í™œì„±í™”ëœ ì¡°ê±´ì‹ ë§¤í•‘ ìƒì„± (ì„œë²„ ìš”ì²­ìš© ë° ì‹ í˜¸ í•„í„°ë§ìš©)
        self.active_buy_conds = {}   # {'ì¡°ê±´ì‹ëª…': ['ì „ëµ1', ...]}
        self.active_sell_conds = {}  # {'ì¡°ê±´ì‹ëª…': ['ì „ëµ1', 'ì „ëµ2', ...]}
        for s_name, cfg in self.STRATEGIES.items():
            if cfg["active"] == 1:
                b_name = cfg["buy_name"].strip()
                s_name_cond = cfg["sell_name"].strip()
                if b_name: self.active_buy_conds.setdefault(b_name, []).append(s_name)
                if s_name_cond: self.active_sell_conds.setdefault(s_name_cond, []).append(s_name)

        self.CSV_FILE_NAME = "trade_history(real).csv"
        # =====================================================================

        self.account_num = None
        self.bought_today = []  
        self.sold_today = []  

        self.held_stocks = {}

        self.buy_meta_data = {}
        self.tr_data_temp = {}
        self.open_buy_orders = {}  
        self.current_deposit = 0  
        self.current_conditioned_stocks = set()
        self.condition_started = False
        
        self.job_queue = []
        self.is_processing_job = False  

        self.history_df = pd.DataFrame()
        self._load_csv_to_memory()

        self.csv_save_timer = QTimer(self)
        self.csv_save_timer.setSingleShot(True)
        self.csv_save_timer.timeout.connect(self._save_csv_to_disk)

        self.kiwoom = QAxWidget("KHOPENAPI.KHOpenAPICtrl.1")
        self.kiwoom.dynamicCall("KOA_Functions(QString, QString)", "SetShowMessage", "0")

        self.kiwoom.OnEventConnect.connect(self._event_connect)
        self.kiwoom.OnReceiveConditionVer.connect(self._handler_condition_load)
        self.kiwoom.OnReceiveTrData.connect(self._handler_tr_data)
        self.kiwoom.OnReceiveMsg.connect(self._handler_msg)

        try:
            self.kiwoom.OnReceiveTrCondition.connect(self._handler_condition)
        except AttributeError:
            self.kiwoom.OnReceiveCondition.connect(self._handler_condition)

        self.kiwoom.OnReceiveRealCondition.connect(self._handler_real_condition)
        self.kiwoom.OnReceiveChejanData.connect(self._handler_chejan_data)

        self.periodic_timer = QTimer(self)
        self.periodic_timer.timeout.connect(self._periodic_check)
        self.periodic_timer.start(60000)

        self.slippage_timer = QTimer(self)
        self.slippage_timer.timeout.connect(self._print_slippage_report)
        self.slippage_timer.start(300000)

        QTimer.singleShot(1000, self._process_job_queue)

    def _safe_delay(self, ms):
        loop = QEventLoop()
        QTimer.singleShot(ms, loop.quit)
        loop.exec_()

    # -------------------------------------
    # [ìœ í‹¸] ì—‘ì…€ ë©”ëª¨ë¦¬ ë¡œë”© ë° ë””ë°”ìš´ì‹±(ì¼ê´„ ì €ì¥) ë¡œì§
    # -------------------------------------
    def _load_csv_to_memory(self):
        columns = [
            'ì¢…ëª©ì½”ë“œ', 'ì¢…ëª©ëª…', 'ë§¤ìˆ˜ì¼', 'ë§¤ìˆ˜ì‹œê°„', 'ë§¤ìˆ˜ëª©í‘œê°€', 'ì‹¤ì œë§¤ì…ê°€', 'ë§¤ìˆ˜ìŠ¬ë¦¬í”¼ì§€(%)',
            'ë§¤ë„ì¼', 'ë§¤ë„ì‹œê°„', 'ë§¤ë„ëª©í‘œê°€', 'ì‹¤ì œë§¤ë„ê°€', 'ë§¤ë„ìŠ¬ë¦¬í”¼ì§€(%)', 'í•©ì‚°ìŠ¬ë¦¬í”¼ì§€(%)',
            'í…ŒìŠ¤íŠ¸ìˆ˜ìµë¥ (%)', 'ì‹¤ì œìˆ˜ìµë¥ (%)', 'ë³´ìœ ê¸°ê°„(ì¼)', 'ì „ëµ'
        ]
        if os.path.exists(self.CSV_FILE_NAME):
            try:
                df = pd.read_csv(self.CSV_FILE_NAME, dtype={'ì¢…ëª©ì½”ë“œ': str})
                self.history_df = self._migrate_history_columns(df)
                self.history_df['ì¢…ëª©ì½”ë“œ'] = self.history_df['ì¢…ëª©ì½”ë“œ'].astype(str).str.replace("'", "").str.zfill(6)

                today_str = datetime.now().strftime('%Y-%m-%d')
                sold_mask = self.history_df['ë§¤ë„ì¼'] == today_str
                for c in self.history_df.loc[sold_mask, 'ì¢…ëª©ì½”ë“œ'].unique():
                    if c not in self.sold_today:
                        self.sold_today.append(c)
            except Exception as e:
                print(f"[ì˜¤ë¥˜] CSV íŒŒì¼ ë©”ëª¨ë¦¬ ë¡œë“œ ì‹¤íŒ¨: {e}")
                self.history_df = pd.DataFrame(columns=columns)
        else:
            self.history_df = pd.DataFrame(columns=columns)

    def _save_csv_to_disk(self):
        if not self.history_df.empty:
            try:
                save_df = self.history_df.copy()
                save_df['ì¢…ëª©ì½”ë“œ'] = save_df['ì¢…ëª©ì½”ë“œ'].apply(lambda x: f"'{x}" if not str(x).startswith("'") else x)
                save_df.to_csv(self.CSV_FILE_NAME, index=False, encoding='utf-8-sig')
                print(f"\n[{datetime.now().strftime('%H:%M:%S')}] ğŸ’¾ [ì¼ê´„ì €ì¥] ì´ë²¤íŠ¸ í•œì‚°ê¸° ë„ë‹¬, ê±°ë˜ ë‚´ì—­ ì—‘ì…€ íŒŒì¼ ì•ˆì „ ê¸°ë¡ ì™„ë£Œ.\n")
            except Exception as e:
                print(f"\n[ê²½ê³ ] ì—‘ì…€ ì¼ê´„ ì €ì¥ ì‹¤íŒ¨ (íŒŒì¼ì´ ì—´ë ¤ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë°ì´í„°ëŠ” ë©”ëª¨ë¦¬ì— ë³´ì¡´ë¨): {e}\n")

    def _migrate_history_columns(self, df):
        rename_map = {
            '5%ìƒìŠ¹ê°€(ë³´ì •X)': 'ë§¤ìˆ˜ëª©í‘œê°€',
            'ëª©í‘œê°€(ë³´ì •X)': 'ë§¤ìˆ˜ëª©í‘œê°€',
            'ìŠ¬ë¦¬í”¼ì§€(%)': 'ë§¤ìˆ˜ìŠ¬ë¦¬í”¼ì§€(%)',
            'ë§¤ë„ê°€ê²©': 'ì‹¤ì œë§¤ë„ê°€',
            'ìˆ˜ìµë¥ (%)': 'ì‹¤ì œìˆ˜ìµë¥ (%)'
        }
        for old, new in rename_map.items():
            if old in df.columns:
                df = df.rename(columns={old: new})

        for col in ['ë§¤ë„ëª©í‘œê°€', 'ë§¤ë„ìŠ¬ë¦¬í”¼ì§€(%)', 'í•©ì‚°ìŠ¬ë¦¬í”¼ì§€(%)', 'í…ŒìŠ¤íŠ¸ìˆ˜ìµë¥ (%)', 'ì „ëµ']:
            if col not in df.columns:
                if col == 'ì „ëµ':
                    df[col] = 'ì „ëµ1' # êµ¬ë²„ì „ í•˜ìœ„í˜¸í™˜
                else:
                    df[col] = ''
        return df

    def _get_hoga_unit(self, price):
        if price < 2000:
            return 1
        elif price < 5000:
            return 5
        elif price < 20000:
            return 10
        elif price < 50000:
            return 50
        elif price < 200000:
            return 100
        elif price < 500000:
            return 500
        else:
            return 1000

    def _adjust_price_to_tick(self, price):
        unit = self._get_hoga_unit(price)
        return int(round(price / unit) * unit)

    # -------------------------------------
    # [í•µì‹¬] CSV ë©”ëª¨ë¦¬ ê¸°ë°˜ ì´ë ¥ ê´€ë¦¬ ë¡œì§ 
    # -------------------------------------
    def _log_buy_trade(self, code, stock_name, buy_date, buy_time, target_raw, buy_price, slippage, strategy):
        if not self.history_df.empty:
            is_duplicate = not self.history_df[
                (self.history_df['ì¢…ëª©ì½”ë“œ'] == code) &
                (self.history_df['ë§¤ìˆ˜ì¼'] == buy_date) &
                (self.history_df['ë§¤ìˆ˜ì‹œê°„'] == buy_time)
                ].empty
            if is_duplicate:
                return

        new_data = {
            'ì¢…ëª©ì½”ë“œ': code,
            'ì¢…ëª©ëª…': stock_name,
            'ë§¤ìˆ˜ì¼': buy_date,
            'ë§¤ìˆ˜ì‹œê°„': buy_time,
            'ë§¤ìˆ˜ëª©í‘œê°€': int(target_raw),
            'ì‹¤ì œë§¤ì…ê°€': buy_price,
            'ë§¤ìˆ˜ìŠ¬ë¦¬í”¼ì§€(%)': round(slippage, 2),
            'ë§¤ë„ì¼': '', 'ë§¤ë„ì‹œê°„': '', 'ë§¤ë„ëª©í‘œê°€': '', 'ì‹¤ì œë§¤ë„ê°€': '',
            'ë§¤ë„ìŠ¬ë¦¬í”¼ì§€(%)': '', 'í•©ì‚°ìŠ¬ë¦¬í”¼ì§€(%)': '', 'í…ŒìŠ¤íŠ¸ìˆ˜ìµë¥ (%)': '',
            'ì‹¤ì œìˆ˜ìµë¥ (%)': '', 'ë³´ìœ ê¸°ê°„(ì¼)': '', 'ì „ëµ': strategy
        }

        self.history_df = pd.concat([self.history_df, pd.DataFrame([new_data])], ignore_index=True)
        print(f"[ê¸°ë¡ëŒ€ê¸°] [{strategy}] ë§¤ìˆ˜ ì´ë ¥ ë©”ëª¨ë¦¬ ë“±ë¡ ì™„ë£Œ: {stock_name}")
        self.csv_save_timer.start(5000)

    def _log_sell_trade(self, code, stock_name, sell_date, sell_time, sell_target_price, actual_sell_price, strategy):
        if self.history_df.empty:
            print(f"[ì˜¤ë¥˜] [{strategy}] ë©”ëª¨ë¦¬ ê¸°ë¡ì´ ì—†ì–´ ë§¤ë„ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {stock_name}")
            return

        mask = (self.history_df['ì¢…ëª©ì½”ë“œ'] == code) & (self.history_df['ë§¤ë„ì¼'].isna() | (self.history_df['ë§¤ë„ì¼'] == ''))
        if not self.history_df.loc[mask].empty:
            idx = self.history_df.loc[mask].index[-1]

            try: buy_target = float(self.history_df.loc[idx, 'ë§¤ìˆ˜ëª©í‘œê°€'])
            except: buy_target = float(self.history_df.loc[idx, 'ì‹¤ì œë§¤ì…ê°€'])

            try: buy_price = float(self.history_df.loc[idx, 'ì‹¤ì œë§¤ì…ê°€'])
            except: buy_price = 0.0

            try: buy_slippage = float(self.history_df.loc[idx, 'ë§¤ìˆ˜ìŠ¬ë¦¬í”¼ì§€(%)'])
            except: buy_slippage = 0.0

            buy_date = str(self.history_df.loc[idx, 'ë§¤ìˆ˜ì¼'])
            try: hold_days = np.busday_count(buy_date, sell_date)
            except: hold_days = 0

            sell_slippage = ((sell_target_price - actual_sell_price) / sell_target_price * 100) if sell_target_price > 0 else 0.0
            total_slippage = buy_slippage + sell_slippage

            test_return = ((sell_target_price - buy_target) / buy_target * 100) if buy_target > 0 else 0.0
            actual_return = ((actual_sell_price - buy_price) / buy_price * 100) if buy_price > 0 else 0.0

            self.history_df.loc[idx, 'ë§¤ë„ì¼'] = sell_date
            self.history_df.loc[idx, 'ë§¤ë„ì‹œê°„'] = sell_time
            self.history_df.loc[idx, 'ë§¤ë„ëª©í‘œê°€'] = int(sell_target_price)
            self.history_df.loc[idx, 'ì‹¤ì œë§¤ë„ê°€'] = int(actual_sell_price)
            self.history_df.loc[idx, 'ë§¤ë„ìŠ¬ë¦¬í”¼ì§€(%)'] = round(sell_slippage, 2)
            self.history_df.loc[idx, 'í•©ì‚°ìŠ¬ë¦¬í”¼ì§€(%)'] = round(total_slippage, 2)
            self.history_df.loc[idx, 'í…ŒìŠ¤íŠ¸ìˆ˜ìµë¥ (%)'] = round(test_return, 2)
            self.history_df.loc[idx, 'ì‹¤ì œìˆ˜ìµë¥ (%)'] = round(actual_return, 2)
            self.history_df.loc[idx, 'ë³´ìœ ê¸°ê°„(ì¼)'] = hold_days

            print(f"[ê¸°ë¡ëŒ€ê¸°] [{strategy}] ë§¤ë„ ì´ë ¥ ì—…ë°ì´íŠ¸ ì™„ë£Œ: {stock_name} (ì‹¤ì œìˆ˜ìµë¥ : {actual_return:.2f}%)")
            self.csv_save_timer.start(5000)
        else:
            print(f"[ì•Œë¦¼] [{strategy}] '{stock_name}'ì˜ ë§¤ìˆ˜ ê¸°ë¡ì„ ì°¾ì„ ìˆ˜ ì—†ì–´ ë§¤ë„ ê¸°ë¡ë§Œ ë³„ë„ë¡œ ë‚¨ê¸¸ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

    def _update_csv_target_price(self, code, target_price, order_type):
        if self.history_df.empty: return
        try:
            if order_type == 'BUY':
                mask = (self.history_df['ì¢…ëª©ì½”ë“œ'] == code) & (
                        self.history_df['ë§¤ë„ì¼'].isna() | (self.history_df['ë§¤ë„ì¼'] == ''))
                if not self.history_df.loc[mask].empty:
                    idx = self.history_df.loc[mask].index[-1]
                    self.history_df.loc[idx, 'ë§¤ìˆ˜ëª©í‘œê°€'] = int(target_price)
                    buy_price = float(self.history_df.loc[idx, 'ì‹¤ì œë§¤ì…ê°€'])
                    if target_price > 0:
                        self.history_df.loc[idx, 'ë§¤ìˆ˜ìŠ¬ë¦¬í”¼ì§€(%)'] = round(((buy_price - target_price) / target_price) * 100, 2)
                    self.csv_save_timer.start(5000)

            elif order_type == 'SELL':
                mask = (self.history_df['ì¢…ëª©ì½”ë“œ'] == code)
                if not self.history_df.loc[mask].empty:
                    idx = self.history_df.loc[mask].index[-1]
                    self.history_df.loc[idx, 'ë§¤ë„ëª©í‘œê°€'] = int(target_price)
                    actual_sell = float(self.history_df.loc[idx, 'ì‹¤ì œë§¤ë„ê°€'])
                    if target_price > 0:
                        sell_slip = ((target_price - actual_sell) / target_price) * 100
                        self.history_df.loc[idx, 'ë§¤ë„ìŠ¬ë¦¬í”¼ì§€(%)'] = round(sell_slip, 2)
                        try: buy_slip = float(self.history_df.loc[idx, 'ë§¤ìˆ˜ìŠ¬ë¦¬í”¼ì§€(%)'])
                        except: buy_slip = 0.0
                        self.history_df.loc[idx, 'í•©ì‚°ìŠ¬ë¦¬í”¼ì§€(%)'] = round(buy_slip + sell_slip, 2)
                        
                        try: buy_target = float(self.history_df.loc[idx, 'ë§¤ìˆ˜ëª©í‘œê°€'])
                        except: buy_target = float(self.history_df.loc[idx, 'ì‹¤ì œë§¤ì…ê°€'])
                        if buy_target > 0:
                            self.history_df.loc[idx, 'í…ŒìŠ¤íŠ¸ìˆ˜ìµë¥ (%)'] = round(((target_price - buy_target) / buy_target) * 100, 2)
                    self.csv_save_timer.start(5000)
        except Exception:
            pass

    # -------------------------------------
    # ì´ˆê¸°í™” ì²´ì¸
    # -------------------------------------
    def _req_outstanding_orders(self):
        print("[ì‹œìŠ¤í…œ] ë¯¸ì²´ê²° ì£¼ë¬¸ ë‚´ì—­ì„ í™•ì¸í•©ë‹ˆë‹¤...")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ê³„ì¢Œë²ˆí˜¸", self.account_num)
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ì „ì²´ì¢…ëª©êµ¬ë¶„", "0")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ë§¤ë§¤êµ¬ë¶„", "0")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ì²´ê²°êµ¬ë¶„", "1")
        self.kiwoom.dynamicCall("CommRqData(QString, QString, int, QString)", "ë¯¸ì²´ê²°ìš”ì²­", "opt10075", 0, "0102")

    def _req_account_balance(self, prev_next="0"):
        if prev_next == "0":
            print("[ì‹œìŠ¤í…œ] ë³´ìœ  ì¢…ëª©(ê³„ì¢Œ ì”ê³ )ì„ í™•ì¸í•©ë‹ˆë‹¤...")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ê³„ì¢Œë²ˆí˜¸", self.account_num)
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ë¹„ë°€ë²ˆí˜¸", "")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ë¹„ë°€ë²ˆí˜¸ì…ë ¥ë§¤ì²´êµ¬ë¶„", "00")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ì¡°íšŒêµ¬ë¶„", "2")
        self.kiwoom.dynamicCall("CommRqData(QString, QString, int, QString)", "ì”ê³ ìš”ì²­", "opw00018", int(prev_next), "0103")

    def _req_deposit(self):
        if not self.account_num: return
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ê³„ì¢Œë²ˆí˜¸", self.account_num)
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ë¹„ë°€ë²ˆí˜¸", "")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ë¹„ë°€ë²ˆí˜¸ì…ë ¥ë§¤ì²´êµ¬ë¶„", "00")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ì¡°íšŒêµ¬ë¶„", "1")
        self.kiwoom.dynamicCall("CommRqData(QString, QString, int, QString)", "ì˜ˆìˆ˜ê¸ˆìš”ì²­", "opw00001", 0, "0105")

    def _get_stock_info(self, code):
        self.tr_data_temp = {}
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ì¢…ëª©ì½”ë“œ", code)
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ê¸°ì¤€ì¼ì", "")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ìˆ˜ì •ì£¼ê°€êµ¬ë¶„", "1")
        res = self.kiwoom.dynamicCall("CommRqData(QString, QString, int, QString)", "ì£¼ì‹ì¼ë´‰ê¸°ë³¸ìš”ì²­", "opt10081", 0, "0104")

        if res != 0:
            print(f"[ì‹œìŠ¤í…œ] ì„œë²„ ê³¼ë¶€í•˜ë¡œ ì£¼ì‹ì¼ë´‰ê¸°ë³¸ìš”ì²­(opt10081) ì°¨ë‹¨ë¨ (ì—ëŸ¬ì½”ë“œ: {res})")
            return self.tr_data_temp

        self.tr_event_loop = QEventLoop()
        QTimer.singleShot(3000, self.tr_event_loop.quit)
        self.tr_event_loop.exec_()

        return self.tr_data_temp

    def _handler_tr_data(self, scr_no, rqname, trcode, recordname, prev_next, data_len, err_code, msg, splm_msg):
        if rqname == "ë¯¸ì²´ê²°ìš”ì²­":
            cnt = self.kiwoom.dynamicCall("GetRepeatCnt(QString, QString)", trcode, rqname)
            for i in range(cnt):
                code = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, i, "ì¢…ëª©ì½”ë“œ").strip()
                order_no = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, i, "ì£¼ë¬¸ë²ˆí˜¸").strip()
                order_type = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, i, "ì£¼ë¬¸êµ¬ë¶„").strip()
                if "ë§¤ìˆ˜" in order_type:
                    self.open_buy_orders[code] = order_no
            print(f"[ì‹œìŠ¤í…œ] ë¯¸ì²´ê²° ë§¤ìˆ˜ ì£¼ë¬¸ ë³µì›: {len(self.open_buy_orders)}ê±´")
            QTimer.singleShot(200, self._req_account_balance)

        elif rqname == "ì”ê³ ìš”ì²­":
            cnt = self.kiwoom.dynamicCall("GetRepeatCnt(QString, QString)", trcode, rqname)
            for i in range(cnt):
                code = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, i, "ì¢…ëª©ë²ˆí˜¸").strip().replace("A", "")
                qty = int(self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, i, "ë³´ìœ ìˆ˜ëŸ‰").strip())
                price = int(self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, i, "ë§¤ì…ê°€").strip())

                if qty > 0:
                    target_raw = 0
                    buy_date = ''
                    buy_time = ''
                    csv_buy_price = price
                    csv_slippage = 0.0
                    strategy = 'ìˆ˜ë™ë§¤ìˆ˜'
                    is_restored_from_csv = False

                    if not self.history_df.empty:
                        mask = (self.history_df['ì¢…ëª©ì½”ë“œ'] == code) & (self.history_df['ë§¤ë„ì¼'].isna() | (self.history_df['ë§¤ë„ì¼'] == ''))
                        if not self.history_df.loc[mask].empty:
                            last_idx = self.history_df.loc[mask].index[-1]
                            try:
                                target_raw = int(self.history_df.loc[last_idx, 'ë§¤ìˆ˜ëª©í‘œê°€'])
                                buy_date = str(self.history_df.loc[last_idx, 'ë§¤ìˆ˜ì¼'])
                                buy_time = str(self.history_df.loc[last_idx, 'ë§¤ìˆ˜ì‹œê°„'])
                                csv_buy_price = float(self.history_df.loc[last_idx, 'ì‹¤ì œë§¤ì…ê°€'])
                                csv_slippage = float(self.history_df.loc[last_idx, 'ë§¤ìˆ˜ìŠ¬ë¦¬í”¼ì§€(%)'])
                                strategy = str(self.history_df.loc[last_idx, 'ì „ëµ'])
                                is_restored_from_csv = True
                            except Exception:
                                pass

                    if not is_restored_from_csv:
                        target_raw = price
                        csv_slippage = 0.0
                        buy_date = 'ìˆ˜ë™ë§¤ìˆ˜(ê¸°ë¡ì—†ìŒ)'
                        buy_time = '00:00:00'
                        strategy = 'ì•Œìˆ˜ì—†ìŒ'
                        stock_name = self.kiwoom.dynamicCall("GetMasterCodeName(QString)", code)
                        self._log_buy_trade(code, stock_name, buy_date, buy_time, target_raw, price, csv_slippage, strategy)

                    if buy_date == datetime.now().strftime('%Y-%m-%d'):
                        if code not in self.bought_today:
                            self.bought_today.append(code)

                    self.held_stocks[code] = {
                        'qty': qty, 'price': price, 'buy_date': buy_date, 'buy_time': buy_time,
                        'target_raw': target_raw, 'type': 'ì§€ì •ê°€',
                        'csv_buy_price': csv_buy_price,
                        'csv_slippage': csv_slippage,
                        'strategy': strategy
                    }

            if prev_next == "2":
                print(f"[ì‹œìŠ¤í…œ] ì”ê³  20ê°œ ì´ˆê³¼ ë°œê²¬! ë‹¤ìŒ í˜ì´ì§€(ì—°ì†ì¡°íšŒ)ë¥¼ ìš”ì²­í•©ë‹ˆë‹¤. (í˜„ì¬ê¹Œì§€ {len(self.held_stocks)}ì¢…ëª© ë³µì›ë¨)")
                QTimer.singleShot(200, lambda: self._req_account_balance(prev_next="2"))
            else:
                print(f"[ì‹œìŠ¤í…œ] ë³´ìœ  ì¢…ëª© ë¦¬ìŠ¤íŠ¸ ë³µì› ì™„ë£Œ: ì´ {len(self.held_stocks)}ì¢…ëª©")
                QTimer.singleShot(200, self._req_deposit)

        elif rqname == "ì˜ˆìˆ˜ê¸ˆìš”ì²­":
            deposit_str = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, 0, "d+2ì¶”ì •ì˜ˆìˆ˜ê¸ˆ").strip()
            self.current_deposit = int(deposit_str) if deposit_str else 0

            now_time_str = datetime.now().strftime('%H%M%S')
            if "085000" <= now_time_str <= "154000":
                if not self.condition_started:
                    self._print_slippage_report()
                    self.condition_started = True
                    QTimer.singleShot(200, self._get_condition_load)
            else:
                if not self.condition_started:
                    print(f"[ì‹œìŠ¤í…œ] í˜„ì¬ëŠ” ì¥ì™¸ ì‹œê°„ì…ë‹ˆë‹¤. (ì˜ˆìˆ˜ê¸ˆ: {self.current_deposit:,}ì›) 08:50ì— ìë™ìœ¼ë¡œ ì‹œì‘í•©ë‹ˆë‹¤.")

        elif rqname == "ì£¼ì‹ì¼ë´‰ê¸°ë³¸ìš”ì²­":
            cnt = self.kiwoom.dynamicCall("GetRepeatCnt(QString, QString)", trcode, rqname)
            op, pc, c_list = 0, 0, []

            if cnt > 0:
                open_price = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, 0, "ì‹œê°€").strip()
                op = abs(int(open_price)) if open_price else 0

                if cnt > 1:
                    prev_close = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, 1, "í˜„ì¬ê°€").strip()
                    pc = abs(int(prev_close)) if prev_close else 0

                for i in range(1, min(cnt, 5)):
                    close_price = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, i, "í˜„ì¬ê°€").strip()
                    c_list.append(abs(int(close_price)) if close_price else 0)

            self.tr_data_temp = {'open': op, 'prev': pc, 'c_list': c_list}
            if hasattr(self, 'tr_event_loop') and self.tr_event_loop.isRunning():
                self.tr_event_loop.quit()

    # -------------------------------------
    # ë©”ì¸ ë¡œì§
    # -------------------------------------
    def _execute_buy(self, code, strategy_name):
        now_time_str = datetime.now().strftime('%H%M%S')
        if not ("090000" <= now_time_str <= "152000"):
            return

        now = datetime.now().strftime('%H:%M:%S')
        stock_name = self.kiwoom.dynamicCall("GetMasterCodeName(QString)", code)

        # ì „ëµ í™˜ê²½ì„¤ì • ë¡œë“œ
        cfg = self.STRATEGIES.get(strategy_name, self.STRATEGIES["ì „ëµ1"])
        max_buy_amount = cfg.get("max_buy", 500000)
        buy_order_type = cfg.get("buy_type", "03")

        if code in self.open_buy_orders:
            print(f"[{now}] [{strategy_name}] [ë§¤ìˆ˜ìŠ¤í‚µ] {stock_name}({code}) - ë¯¸ì²´ê²° ë§¤ìˆ˜ ì£¼ë¬¸ ëŒ€ê¸° ì¤‘")
            return

        if code in self.held_stocks:
            print(f"[{now}] [{strategy_name}] [ë§¤ìˆ˜ìŠ¤í‚µ] {stock_name}({code}) - ì´ë¯¸ ë³´ìœ  ì¤‘ì¸ ì¢…ëª©")
            return

        if code in self.bought_today:
            return

        if code in self.sold_today:
            print(f"[{now}] [{strategy_name}] [ë§¤ìˆ˜ìŠ¤í‚µ] {stock_name}({code}) - ë‹¹ì¼ ë§¤ë„ ì¢…ëª© (ì¬ë§¤ìˆ˜ ë°©ì§€)")
            return

        now_ts = time.time()
        if code in self.buy_meta_data:
            last_ts = self.buy_meta_data[code].get('timestamp', 0)
            if now_ts - last_ts < 2.0:
                return

        required_margin = max_buy_amount * 1.3
        if self.current_deposit <= required_margin:
            print(f"[{now}] [{strategy_name}] [ë§¤ìˆ˜ìŠ¤í‚µ] {stock_name}({code}) - ì¦ê±°ê¸ˆ ë¶€ì¡± ì‚¬ì „ ì°¨ë‹¨ (ì˜ˆìˆ˜ê¸ˆ: {int(self.current_deposit):,}ì› / í•„ìš”: {int(required_margin):,}ì›)")
            return

        # 1. ì§€ì—° ì—†ëŠ” ì¦‰ì‹œ ì£¼ë¬¸
        current_price_str = self.kiwoom.dynamicCall("GetMasterLastPrice(QString)", code)
        current_price = abs(int(current_price_str)) if current_price_str else 0

        if current_price == 0:
            print(f"[{now}] [{strategy_name}] [ë§¤ìˆ˜ë¶ˆê°€] {stock_name}({code}) - í˜„ì¬ê°€ ì¡°íšŒ ë¶ˆê°€")
            return

        quantity = max_buy_amount // current_price
        if quantity == 0:
            print(f"[{now}] [{strategy_name}] [ë§¤ìˆ˜ë¶ˆê°€] {stock_name}({code}) - ë‹¨ê°€ ì´ˆê³¼")
            return

        print(f"[{now}] ğŸš€ [{strategy_name}] [ìë™ë§¤ìˆ˜] {stock_name}({code}) {quantity}ì£¼ ì¦‰ì‹œ ì£¼ë¬¸ ë°œì†¡! (í˜¸ê°€êµ¬ë¶„: {buy_order_type})")
        self.buy_meta_data[code] = {'target_raw': 0, 'time': now, 'timestamp': now_ts, 'strategy': strategy_name}

        self.current_deposit -= (quantity * current_price)

        self._send_order(code, 1, quantity, 0, buy_order_type)

        # 2. ì£¼ë¬¸ í›„ ì—¬ìœ ë¡­ê²Œ ë°±í…ŒìŠ¤íŠ¸ ëª©í‘œê°€ ê³„ì‚°
        try:
            info = self._get_stock_info(code)
            open_price = info.get('open', current_price)
            prev_price = info.get('prev', current_price)

            target_raw_int = 0
            if strategy_name == "ì „ëµ1":
                target_price = math.ceil(prev_price * 1.05)
                buy_req_price = target_price  # ì „ì¼ì¢…ê°€ ëŒ€ë¹„ 5% ìƒìŠ¹ê°€ë¡œ ê³ ì •
                target_raw_int = int(open_price) if open_price > buy_req_price else int(buy_req_price)
            elif strategy_name == "ì „ëµ2":
                pass # ì¶”í›„ ì „ëµ2 ë§¤ìˆ˜ëª©í‘œê°€ ë¡œì§ ì¶”ê°€ ì˜ˆì •
            elif strategy_name == "ì „ëµ3":
                pass # ì¶”í›„ ì „ëµ3 ë§¤ìˆ˜ëª©í‘œê°€ ë¡œì§ ì¶”ê°€ ì˜ˆì •
            elif strategy_name == "ì „ëµ4":
                pass # ì¶”í›„ ì „ëµ4 ë§¤ìˆ˜ëª©í‘œê°€ ë¡œì§ ì¶”ê°€ ì˜ˆì •
            elif strategy_name == "ì „ëµ5":
                pass # ì¶”í›„ ì „ëµ5 ë§¤ìˆ˜ëª©í‘œê°€ ë¡œì§ ì¶”ê°€ ì˜ˆì •

            # 3. ì‚¬í›„ ë©”ëª¨ë¦¬ ì—…ë°ì´íŠ¸
            self.buy_meta_data[code]['target_raw'] = target_raw_int
            print(f"  > (ì‚¬í›„ê¸°ë¡) [{strategy_name}] ë°±í…ŒìŠ¤íŠ¸ ë§¤ìˆ˜ëª©í‘œê°€ ì‚°ì¶œ ì™„ë£Œ: {target_raw_int:,}ì›")

            self._update_csv_target_price(code, target_raw_int, 'BUY')

            if code in self.held_stocks:
                self.held_stocks[code]['target_raw'] = target_raw_int
                if target_raw_int > 0:
                    buy_price = self.held_stocks[code]['csv_buy_price']
                    self.held_stocks[code]['csv_slippage'] = ((buy_price - target_raw_int) / target_raw_int) * 100

        except Exception as e:
            print(f"[{now}] [{strategy_name}] [ì˜¤ë¥˜] ê°€ê²©ì •ë³´ ì‚¬í›„ ì¡°íšŒ ì‹¤íŒ¨: {code} ({e})")

    def _execute_sell(self, code):
        now_time_str = datetime.now().strftime('%H%M%S')
        if not ("090000" <= now_time_str <= "153000"):
            return

        now = datetime.now().strftime('%H:%M:%S')
        stock_name = self.kiwoom.dynamicCall("GetMasterCodeName(QString)", code)

        # ë§¤ìˆ˜í•  ë•Œ ë‹¬ì•„ë‘” ê¼¬ë¦¬í‘œ(ì „ëµëª…) í™•ì¸
        strategy_name = self.held_stocks[code].get('strategy', 'ì•Œìˆ˜ì—†ìŒ')
        cfg = self.STRATEGIES.get(strategy_name, self.STRATEGIES.get("ì „ëµ1"))
        sell_order_type = cfg.get("sell_type", "03") if cfg else "03"

        if code in self.bought_today:
            print(f"[{now}] [{strategy_name}] [ë§¤ë„ìŠ¤í‚µ] {stock_name} - ë‹¹ì¼ ë§¤ìˆ˜ ì¢…ëª©")
            return

        if code in self.held_stocks and self.held_stocks[code]['qty'] > 0:
            quantity = self.held_stocks[code]['qty']

            # 1. ì§€ì—°ì‹œê°„ 0ì´ˆ ì¦‰ì‹œ ì£¼ë¬¸ ë°œì†¡
            print(f"[{now}] ğŸš€ [{strategy_name}] [ìë™ë§¤ë„] {stock_name} {quantity}ì£¼ ì¦‰ì‹œ ì£¼ë¬¸ ë°œì†¡! (í˜¸ê°€êµ¬ë¶„: {sell_order_type})")
            self._send_order(code, 2, quantity, 0, sell_order_type)

            # 2. ì£¼ë¬¸ í›„ ë°±í…ŒìŠ¤íŠ¸ ë§¤ë„ëª©í‘œê°€ ê³„ì‚°
            info = self._get_stock_info(code)
            c_list = info.get('c_list', [])
            open_price = info.get('open', 0)

            sell_target_price = 0
            if strategy_name == "ì „ëµ1":
                if len(c_list) >= 4:
                    c_1, c_2, c_3, c_4 = c_list[0], c_list[1], c_list[2], c_list[3]
                    cross_price = round(1.5 * (c_3 + c_4) - (c_1 + c_2))
                    sell_target_price = open_price if 0 < open_price < cross_price else cross_price
            elif strategy_name == "ì „ëµ2":
                pass # ì¶”í›„ ì „ëµ2 ë§¤ë„ëª©í‘œê°€ ë¡œì§ ì¶”ê°€ ì˜ˆì •
            elif strategy_name == "ì „ëµ3":
                pass # ì¶”í›„ ì „ëµ3 ë§¤ë„ëª©í‘œê°€ ë¡œì§ ì¶”ê°€ ì˜ˆì •
            elif strategy_name == "ì „ëµ4":
                pass # ì¶”í›„ ì „ëµ4 ë§¤ë„ëª©í‘œê°€ ë¡œì§ ì¶”ê°€ ì˜ˆì •
            elif strategy_name == "ì „ëµ5":
                pass # ì¶”í›„ ì „ëµ5 ë§¤ë„ëª©í‘œê°€ ë¡œì§ ì¶”ê°€ ì˜ˆì •

            if sell_target_price == 0:
                current_price_str = self.kiwoom.dynamicCall("GetMasterLastPrice(QString)", code)
                sell_target_price = abs(int(current_price_str)) if current_price_str else 0

            self.held_stocks[code]['sell_target_price'] = sell_target_price
            print(f"  > (ì‚¬í›„ê¸°ë¡) [{strategy_name}] ë°±í…ŒìŠ¤íŠ¸ ë§¤ë„ëª©í‘œê°€ ì‚°ì¶œ ì™„ë£Œ: {sell_target_price:,}ì›")

            # 3. ì‚¬í›„ ë©”ëª¨ë¦¬ ì—…ë°ì´íŠ¸
            self._update_csv_target_price(code, sell_target_price, 'SELL')
        else:
            print(f"[{now}] [{strategy_name}] [ë§¤ë„ë¶ˆê°€] {stock_name} - ì”ê³  ì—†ìŒ")

    # -------------------------------------
    # ì‘ì—… í ì²˜ë¦¬
    # -------------------------------------
    def _process_job_queue(self):
        if self.is_processing_job:
            QTimer.singleShot(200, self._process_job_queue)
            return

        if not self.job_queue:
            QTimer.singleShot(500, self._process_job_queue)
            return

        now_time_str = datetime.now().strftime('%H%M%S')
        if now_time_str < "090000":
            QTimer.singleShot(500, self._process_job_queue)
            return
        elif now_time_str > "153000":
            self.job_queue.clear()
            QTimer.singleShot(1000, self._process_job_queue)
            return

        self.is_processing_job = True

        try:
            job = self.job_queue.pop(0)
            job_type = job['type']
            code = job['code']

            if job_type == 'BUY':
                strategy_name = job.get('strategy', 'ì „ëµ1')
                self._execute_buy(code, strategy_name)
            elif job_type == 'SELL':
                self._execute_sell(code)
        finally:
            self.is_processing_job = False
            QTimer.singleShot(300, self._process_job_queue)

    # -------------------------------------
    # ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
    # -------------------------------------
    def comm_connect(self):
        print("[ì‹œìŠ¤í…œ] ë¡œê·¸ì¸ ì‹œë„...")
        self.kiwoom.dynamicCall("CommConnect()")
        self.login_event_loop = QEventLoop()
        self.login_event_loop.exec_()

    def _event_connect(self, err_code):
        if err_code == 0:
            print("ë¡œê·¸ì¸ ì„±ê³µ!")
            self.kiwoom.dynamicCall("KOA_Functions(QString, QString)", "SetShowMessage", "0")
            self._get_account_info()
            QTimer.singleShot(200, self._req_outstanding_orders)
        else:
            print("ë¡œê·¸ì¸ ì‹¤íŒ¨")
            self.login_event_loop.exit()

    def _handler_msg(self, scr_no, rqname, trcode, msg):
        if "ë§¤ìˆ˜" in rqname or "ì£¼ë¬¸" in msg:
            print(f"[ì„œë²„ë©”ì‹œì§€] {msg}")
        elif "ì¡°íšŒ" in msg or "ì´ˆê³¼" in msg or "ì œí•œ" in msg:
            print(f"[ì„œë²„ê²½ê³ ] {msg}")

    def after_login(self):
        self.login_event_loop.exit()

    def _get_account_info(self):
        self.account_num = self.kiwoom.dynamicCall("GetLoginInfo(QString)", "ACCNO").split(';')[0]
        print(f"[ë‚´ ì •ë³´] ê³„ì¢Œë²ˆí˜¸: {self.account_num}")

    def _get_condition_load(self):
        self.kiwoom.dynamicCall("GetConditionLoad()")

    def _handler_condition_load(self, ret, msg):
        if ret == 1:
            print("[ì‹œìŠ¤í…œ] ì¡°ê±´ì‹ ë¡œë”© ì™„ë£Œ.")
            conditions = self.kiwoom.dynamicCall("GetConditionNameList()").split(";")[:-1]
            all_active_conds = set(self.active_buy_conds.keys()) | set(self.active_sell_conds.keys())
            
            for c in conditions:
                idx, name = c.split('^')
                name = name.strip()
                if name in all_active_conds:
                    print(f"[{name}] ì´ˆê¸° ê²€ìƒ‰ ë° ì‹¤ì‹œê°„ ê°ì‹œ ìš”ì²­...")
                    self.kiwoom.dynamicCall("SendCondition(QString, QString, int, int)",
                                            "0156" if name in self.active_buy_conds else "0157", name, int(idx), 1)
                    self._safe_delay(1500)

    def _handler_condition(self, scr_no, code_list, cond_name, cond_index, next):
        now = datetime.now().strftime('%H:%M:%S')
        codes = code_list.split(';')[:-1] if code_list else []
        cond_name = cond_name.strip()
        print(f"\n[{now}] [{cond_name}] ê²€ìƒ‰ ê²°ê³¼: {len(codes)}ì¢…ëª©")

        # ë§¤ë„ ì¡°ê±´ì‹ í¬ì°© ì‹œ
        if cond_name in self.active_sell_conds:
            valid_strategies = self.active_sell_conds[cond_name]
            # ê³µí†µ ë§¤ë„ì‹ì¼ ê²½ìš°, í•´ë‹¹ ë§¤ë„ì‹ì„ ì‚¬ìš©í•˜ëŠ” ì „ëµ ê¼¬ë¦¬í‘œë¥¼ ë‹¬ê³  ìˆëŠ” ì¢…ëª©ë§Œ ë°œë¼ëƒ„
            sell_targets = [c for c in codes if c in self.held_stocks and self.held_stocks[c].get('strategy') in valid_strategies]
            if sell_targets:
                print(f"  > [ë§¤ë„ëŒ€ìƒë°œê²¬] ì”ê³  ì¤‘ ì¡°ê±´(ì „ëµ) ì¼ì¹˜: {len(sell_targets)}ì¢…ëª© ë°œê²¬ (9ì‹œ ì •ê° ë°œì‚¬ ëŒ€ê¸°ì—´ì— ë“±ë¡!)")
                for code in sell_targets:
                    if not any(job['type'] == 'SELL' and job['code'] == code for job in self.job_queue):
                        self.job_queue.append({'type': 'SELL', 'code': code})
            else:
                print(f"  > [ë§¤ë„ëŒ€ìƒì—†ìŒ] ê²€ìƒ‰ëœ ì¢…ëª© ì¤‘ í˜„ì¬ ì”ê³ (í•´ë‹¹ ì „ëµ)ì— ë³´ìœ í•œ ì¢…ëª©ì´ ì—†ìŠµë‹ˆë‹¤.")

        # ë§¤ìˆ˜ ì¡°ê±´ì‹ í¬ì°© ì‹œ (ì¥ì „ ë¬´ì‹œ ë¡œì§)
        elif cond_name in self.active_buy_conds:
            for code in codes:
                self.current_conditioned_stocks.add(code)
            strats_using_this = ", ".join(self.active_buy_conds[cond_name])
            print(f"  > [ë§¤ìˆ˜ì´ˆê¸°ë¬´ì‹œ] [{strats_using_this}] ì¥ì „ í¬ì°©ëœ ì¢…ëª© {len(codes)}ê°œëŠ” ë‡Œë™ë§¤ë§¤ ë°©ì§€ë¥¼ ìœ„í•´ ë¬´ì‹œí•©ë‹ˆë‹¤. (ì‹¤ì‹œê°„ ëŒ€ê¸°)")

    def _handler_real_condition(self, code, type, cond_name, cond_index):
        now = datetime.now().strftime('%H:%M:%S')
        cond_name = cond_name.strip()
        
        if type == 'I': 
            if cond_name in self.active_buy_conds:
                self.current_conditioned_stocks.add(code)
                for strat in self.active_buy_conds[cond_name]:
                    self.job_queue.append({'type': 'BUY', 'code': code, 'strategy': strat})
                    
            if cond_name in self.active_sell_conds:
                if code in self.held_stocks:
                    buy_strat = self.held_stocks[code].get('strategy')
                    if buy_strat in self.active_sell_conds[cond_name]:
                        if not any(job['type'] == 'SELL' and job['code'] == code for job in self.job_queue):
                            self.job_queue.append({'type': 'SELL', 'code': code})
                            
        elif type == 'D': 
            if cond_name in self.active_buy_conds:
                self.current_conditioned_stocks.discard(code)
            if cond_name in self.active_sell_conds:
                original_len = len(self.job_queue)
                # ë°œì‚¬ ëŒ€ê¸°ì—´ì—ì„œ ì‚­ì œ
                self.job_queue = [job for job in self.job_queue if not (job['type'] == 'SELL' and job['code'] == code)]
                if len(self.job_queue) < original_len:
                    stock_name = self.kiwoom.dynamicCall("GetMasterCodeName(QString)", code)
                    print(f"[{now}] ğŸ›¡ï¸ [ë§¤ë„ë³´ë¥˜] {stock_name}({code}) - ì¡°ê±´ ì´íƒˆë¡œ ëŒ€ê¸°ì—´ ì‚­ì œ (í—ˆìˆ˜ í˜¸ê°€ ë°©ì–´)")

    def _send_order(self, code, order_type, quantity, price, hoga_gb, order_no=""):
        # ë‹¤ì¤‘ì „ëµ í™˜ê²½ì´ë¯€ë¡œ hoga_gb (í˜¸ê°€êµ¬ë¶„)ì„ ì¸ìë¡œ ì§ì ‘ ë°›ë„ë¡ ìˆ˜ì •
        if order_type == 1 or order_type == 2:
            if hoga_gb == "03": price = 0
            elif hoga_gb == "00" and price == 0:
                current_price_str = self.kiwoom.dynamicCall("GetMasterLastPrice(QString)", code)
                price = abs(int(current_price_str)) if current_price_str else 0
        else:
            hoga_gb = "00"

        self.kiwoom.dynamicCall("SendOrder(QString, QString, QString, int, QString, int, int, QString, QString)",
                                ["send_order", "0101", self.account_num, order_type, code, quantity, price, hoga_gb, order_no])

    def _handler_chejan_data(self, gubun, item_cnt, fid_list):
        if gubun == '0':  # ì ‘ìˆ˜/ì²´ê²°
            status = self.kiwoom.dynamicCall("GetChejanData(int)", 913)
            code = self.kiwoom.dynamicCall("GetChejanData(int)", 9001).replace('A', '').strip()
            order_no = self.kiwoom.dynamicCall("GetChejanData(int)", 9203)
            order_type = self.kiwoom.dynamicCall("GetChejanData(int)", 905)

            if "ë§¤ìˆ˜" in order_type:
                if status == "ì ‘ìˆ˜":
                    self.open_buy_orders[code] = order_no
                elif status == "ì²´ê²°":
                    if code in self.open_buy_orders: del self.open_buy_orders[code]

                    if code not in self.held_stocks or 'buy_date' not in self.held_stocks[code]:
                        buy_price = int(self.kiwoom.dynamicCall("GetChejanData(int)", 910))
                        stock_name = self.kiwoom.dynamicCall("GetMasterCodeName(QString)", code)
                        today = datetime.now().strftime('%Y-%m-%d')
                        now_time = datetime.now().strftime('%H:%M:%S')

                        target_raw = 0
                        strategy = 'ìˆ˜ë™/ì•Œìˆ˜ì—†ìŒ'
                        if code in self.buy_meta_data: 
                            target_raw = self.buy_meta_data[code].get('target_raw', 0)
                            strategy = self.buy_meta_data[code].get('strategy', 'ìˆ˜ë™/ì•Œìˆ˜ì—†ìŒ')

                        slippage = ((buy_price - target_raw) / target_raw) * 100 if target_raw > 0 else 0

                        self._log_buy_trade(code, stock_name, today, now_time, target_raw, buy_price, slippage, strategy)

                        existing_qty = self.held_stocks[code].get('qty', 0) if code in self.held_stocks else 0

                        self.held_stocks[code] = {
                            'qty': existing_qty, 'price': buy_price, 'buy_date': today, 'buy_time': now_time,
                            'target_raw': target_raw, 'type': 'ì§€ì •ê°€', 'csv_buy_price': buy_price,
                            'csv_slippage': buy_price, 'strategy': strategy
                        }

                        if code not in self.bought_today:
                            self.bought_today.append(code)

            elif "ë§¤ë„" in order_type and status == "ì²´ê²°":
                actual_sell_price = int(self.kiwoom.dynamicCall("GetChejanData(int)", 910))
                stock_name = self.kiwoom.dynamicCall("GetMasterCodeName(QString)", code)
                today = datetime.now().strftime('%Y-%m-%d')
                now_time = datetime.now().strftime('%H:%M:%S')

                sell_target_price = 0
                strategy = 'ì•Œìˆ˜ì—†ìŒ'
                if code in self.held_stocks:
                    sell_target_price = self.held_stocks[code].get('sell_target_price', 0)
                    strategy = self.held_stocks[code].get('strategy', 'ì•Œìˆ˜ì—†ìŒ')

                if sell_target_price == 0:
                    sell_target_price = actual_sell_price

                self._log_sell_trade(code, stock_name, today, now_time, sell_target_price, actual_sell_price, strategy)

                if code not in self.sold_today:
                    self.sold_today.append(code)

                QTimer.singleShot(1000, self._req_deposit)

            print(f"[ì²´ê²°ì•Œë¦¼] {code} | {status} | {order_no}")

        elif gubun == '1':  # ì”ê³ í†µë³´
            code = self.kiwoom.dynamicCall("GetChejanData(int)", 9001).replace('A', '').strip()
            qty = int(self.kiwoom.dynamicCall("GetChejanData(int)", 930))
            if qty > 0:
                if code in self.held_stocks:
                    self.held_stocks[code]['qty'] = qty

                    avg_price_str = self.kiwoom.dynamicCall("GetChejanData(int)", 931)
                    avg_price = abs(int(avg_price_str)) if avg_price_str else 0

                    if avg_price > 0:
                        self.held_stocks[code]['price'] = avg_price
                        self.held_stocks[code]['csv_buy_price'] = avg_price

                        if not self.history_df.empty:
                            mask = (self.history_df['ì¢…ëª©ì½”ë“œ'] == code) & (
                                    self.history_df['ë§¤ë„ì¼'].isna() | (self.history_df['ë§¤ë„ì¼'] == ''))
                            if not self.history_df.loc[mask].empty:
                                idx = self.history_df.loc[mask].index[-1]
                                self.history_df.loc[idx, 'ì‹¤ì œë§¤ì…ê°€'] = avg_price

                                target_raw = self.history_df.loc[idx, 'ë§¤ìˆ˜ëª©í‘œê°€']
                                if target_raw and str(target_raw).strip() != '' and float(target_raw) > 0:
                                    t_raw = float(target_raw)
                                    new_slippage = round(((avg_price - t_raw) / t_raw) * 100, 2)
                                    self.history_df.loc[idx, 'ë§¤ìˆ˜ìŠ¬ë¦¬í”¼ì§€(%)'] = new_slippage
                                    self.held_stocks[code]['csv_slippage'] = new_slippage

                        self.csv_save_timer.start(5000)
                else:
                    self.held_stocks[code] = {'qty': qty, 'price': 0, 'strategy': 'ì•Œìˆ˜ì—†ìŒ'}
            else:
                if code in self.held_stocks: del self.held_stocks[code]

    def _periodic_check(self):
        self._req_deposit()

        now_time_str = datetime.now().strftime('%H%M%S')
        if "085000" <= now_time_str <= "154000":
            if not self.condition_started:
                print(f"\n[ì‹œìŠ¤í…œ] ì§€ì • ì‹œê°„ ë„ë‹¬. ì¡°ê±´ì‹ ë¡œë”© ë° ì‹¤ì‹œê°„ ê°ì‹œë¥¼ ìë™ ì‹œì‘í•©ë‹ˆë‹¤.")
                self.condition_started = True
                self._get_condition_load()
        else:
            self.condition_started = False
            return  

        now = datetime.now()
        print(f"\n[ì‹œìŠ¤í…œ ì ê²€] {now.strftime('%H:%M:%S')} ë‹¤ì¤‘ ì „ëµ ì‹¤ì‹œê°„ ê°ì‹œ ì‘ë™ ì¤‘...")

        search_count = len(self.current_conditioned_stocks)
        print(f"  > [ì‹¤ì‹œê°„ ê²€ìƒ‰] í˜„ì¬ ë§¤ìˆ˜ ì¡°ê±´ í¬ì°© ì¢…ëª© ìˆ˜: {search_count}ê°œ")
        print(f"  > [ê³„ì¢Œ í˜„í™©] ë³´ìœ ì¢…ëª©: {len(self.held_stocks)}ê°œ, ë¯¸ì²´ê²°ì£¼ë¬¸: {len(self.open_buy_orders)}ê±´")

        if self.job_queue:
            print(f"  > [ëŒ€ê¸° ì‘ì—…] í˜„ì¬ íì—ì„œ {len(self.job_queue)}ê°œì˜ ì‘ì—…(ë§¤ìˆ˜/ë§¤ë„ ëŒ€ê¸°)ì´ ìˆœì°¨ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤.")

        if now.hour == 15 and now.minute >= 20 and self.open_buy_orders:
            print("[ì¥ë§ˆê°] ë¯¸ì²´ê²° ì·¨ì†Œ")
            for code, order_no in list(self.open_buy_orders.items()):
                self._send_order(code, 3, 0, 0, "00", order_no)
                del self.open_buy_orders[code]
                self._safe_delay(300)

    def _print_slippage_report(self):
        now_time_str = datetime.now().strftime('%H%M%S')
        if not ("085000" <= now_time_str <= "154000"):
            return

        # [ì‹ ê·œ] ì—‘ì…€(ì¥ë¶€)ì—ëŠ” ë³´ìœ ì¤‘ì¸ë°, ì‹¤ì œ ì”ê³ ì—ëŠ” ì—†ëŠ” ì¢…ëª©(ìˆ˜ë™ë§¤ë„) ì—‘ì…€ ë™ê¸°í™”
        if not self.history_df.empty:
            today_str = datetime.now().strftime('%Y-%m-%d')
            now_time = datetime.now().strftime('%H:%M:%S')
            
            unsold_mask = self.history_df['ë§¤ë„ì¼'].isna() | (self.history_df['ë§¤ë„ì¼'] == '')
            unsold_df = self.history_df[unsold_mask]
            
            needs_save = False
            for idx, row in unsold_df.iterrows():
                code = str(row['ì¢…ëª©ì½”ë“œ'])
                if code not in self.held_stocks:
                    stock_name = str(row.get('ì¢…ëª©ëª…', ''))
                    print(f"[{now_time}] âš ï¸ [ìˆ˜ë™ë§¤ë„ ê°ì§€] {stock_name}({code}) - ì”ê³  ì¦ë°œ. ì—‘ì…€ì— ìˆ˜ë™ë§¤ë„(0ì›)ë¡œ ì²˜ë¦¬í•©ë‹ˆë‹¤.")
                    
                    self.history_df.loc[idx, 'ë§¤ë„ì¼'] = today_str
                    self.history_df.loc[idx, 'ë§¤ë„ì‹œê°„'] = now_time
                    self.history_df.loc[idx, 'ë§¤ë„ëª©í‘œê°€'] = 0
                    self.history_df.loc[idx, 'ì‹¤ì œë§¤ë„ê°€'] = 0
                    self.history_df.loc[idx, 'ë§¤ë„ìŠ¬ë¦¬í”¼ì§€(%)'] = 0.0
                    self.history_df.loc[idx, 'í•©ì‚°ìŠ¬ë¦¬í”¼ì§€(%)'] = 0.0
                    self.history_df.loc[idx, 'í…ŒìŠ¤íŠ¸ìˆ˜ìµë¥ (%)'] = 0.0
                    self.history_df.loc[idx, 'ì‹¤ì œìˆ˜ìµë¥ (%)'] = 0.0
                    
                    buy_date = str(self.history_df.loc[idx, 'ë§¤ìˆ˜ì¼'])
                    try: 
                        hold_days = np.busday_count(buy_date, today_str)
                    except: 
                        hold_days = 0
                    self.history_df.loc[idx, 'ë³´ìœ ê¸°ê°„(ì¼)'] = hold_days
                    
                    needs_save = True
            
            if needs_save:
                self.csv_save_timer.start(5000)

        # í•œê¸€(ê°€ë³€í­) ì½˜ì†” ì •ë ¬ìš© í—¬í¼ í•¨ìˆ˜
        def pad(text, width):
            text = str(text)
            length = sum(1.7 if unicodedata.east_asian_width(c) in ['W', 'F'] else 1 for c in text)
            return text + " " * int(max(0, width - length))

        print(f"\n[ì‹œìŠ¤í…œ] ìŠ¬ë¦¬í”¼ì§€ ë° ë‹¹ì¼ ì²´ê²° ì¢…í•© ë¶„ì„ ({datetime.now().strftime('%H:%M:%S')})")
        print("=" * 120)
        
        # --- 1. ë³´ìœ  ì¢…ëª© ---
        print("â–  í˜„ì¬ ë³´ìœ  ì¢…ëª© ìŠ¬ë¦¬í”¼ì§€")
        if not self.held_stocks: 
            print("  - ë³´ìœ  ì¤‘ì¸ ì¢…ëª©ì´ ì—†ìŠµë‹ˆë‹¤.")
        else:
            print("-" * 120)
            header1 = f"{pad('ì¢…ëª©ëª…', 20)}| {pad('ì „ëµ', 10)}| {pad('ë§¤ìˆ˜ì¼ì‹œ', 20)}| {pad('ëª©í‘œê°€', 10)}| {pad('ë§¤ì…ê°€', 10)}| {pad('ìŠ¬ë¦¬í”¼ì§€%', 10)}"
            print(header1)
            print("-" * 120)
            
            total_slippage = 0
            count = 0
            
            # ì‹œê°„ìˆœ ì •ë ¬ (ìµœê·¼ ê²ƒì´ ë§¨ ì•„ë˜ë¡œ ì˜¤ë„ë¡)
            sorted_held = sorted(self.held_stocks.items(), key=lambda x: (x[1].get('buy_date', ''), x[1].get('buy_time', '')))
            
            for code, info in sorted_held:
                name = self.kiwoom.dynamicCall("GetMasterCodeName(QString)", code)
                strat = info.get('strategy', '')
                target = info.get('target_raw', 0)
                buy_price = info.get('csv_buy_price', info['price'])
                slippage = info.get('csv_slippage', 0.0)
                total_slippage += slippage
                count += 1
                
                dt_str = f"{info.get('buy_date', '')} {info.get('buy_time', '')}"
                row_str = f"{pad(name, 20)}| {pad(strat, 10)}| {pad(dt_str, 20)}| {pad(int(target), 10)}| {pad(int(buy_price), 10)}| {pad(f'{slippage:.2f}%', 10)}"
                print(row_str)
            
            print("-" * 120)
            if count > 0:
                print(f"  > ì „ì²´ í‰ê·  ë§¤ìˆ˜ ìŠ¬ë¦¬í”¼ì§€: {total_slippage / count:.2f}%")

        # --- 2. ë‹¹ì¼ ì²´ê²° ë‚´ì—­ ---
        print("\nâ–  ë‹¹ì¼ ì²´ê²° ë‚´ì—­ (ë§¤ìˆ˜/ë§¤ë„)")
        today_str = datetime.now().strftime('%Y-%m-%d')
        if not self.history_df.empty:
            mask = (self.history_df['ë§¤ìˆ˜ì¼'] == today_str) | (self.history_df['ë§¤ë„ì¼'] == today_str)
            today_trades = self.history_df[mask]
            
            if today_trades.empty:
                print("  - ë‹¹ì¼ ì²´ê²° ë‚´ì—­ì´ ì—†ìŠµë‹ˆë‹¤.")
            else:
                print("-" * 120)
                header2 = f"{pad('ì¢…ëª©ëª…', 20)}| {pad('ì „ëµ', 10)}| {pad('êµ¬ë¶„', 6)}| {pad('ì‹œê°„', 10)}| {pad('ë§¤ìˆ˜ìŠ¬ë¦½', 10)}| {pad('ë§¤ë„ìŠ¬ë¦½', 10)}| {pad('í•©ì‚°ìŠ¬ë¦½', 10)}| {pad('ìˆ˜ìµ(ì„¸ì „)', 12)}| {pad('ìˆ˜ìµ(ì„¸í›„)', 12)}"
                print(header2)
                print("-" * 120)
                
                trade_records = []
                
                for _, row in today_trades.iterrows():
                    name = str(row.get('ì¢…ëª©ëª…', ''))
                    strat = str(row.get('ì „ëµ', ''))
                    buy_time = str(row.get('ë§¤ìˆ˜ì‹œê°„', ''))
                    sell_time = str(row.get('ë§¤ë„ì‹œê°„', ''))
                    
                    buy_slip = row.get('ë§¤ìˆ˜ìŠ¬ë¦¬í”¼ì§€(%)', '')
                    sell_slip = row.get('ë§¤ë„ìŠ¬ë¦¬í”¼ì§€(%)', '')
                    total_slip = row.get('í•©ì‚°ìŠ¬ë¦¬í”¼ì§€(%)', '')
                    actual_return = row.get('ì‹¤ì œìˆ˜ìµë¥ (%)', '')
                    
                    b_slip_str = f"{float(buy_slip):.2f}%" if pd.notna(buy_slip) and str(buy_slip).strip() else "-"
                    s_slip_str = f"{float(sell_slip):.2f}%" if pd.notna(sell_slip) and str(sell_slip).strip() else "-"
                    t_slip_str = f"{float(total_slip):.2f}%" if pd.notna(total_slip) and str(total_slip).strip() else "-"
                    
                    is_bought_today = str(row.get('ë§¤ìˆ˜ì¼', '')) == today_str
                    is_sold_today = pd.notna(row.get('ë§¤ë„ì¼')) and str(row.get('ë§¤ë„ì¼')) == today_str
                    
                    if is_bought_today and is_sold_today:
                        gubun = "ë§¤ë§¤"  
                        trade_time = sell_time
                    elif is_sold_today:
                        gubun = "ë§¤ë„"
                        trade_time = sell_time
                    else:
                        gubun = "ë§¤ìˆ˜"
                        trade_time = buy_time
                    
                    if is_sold_today:
                        ret_str = f"{float(actual_return):.2f}%" if pd.notna(actual_return) and str(actual_return).strip() else "-"
                        if pd.notna(actual_return) and str(actual_return).strip():
                            ret_after_tax = float(actual_return) - 0.23
                            ret_after_tax_str = f"{ret_after_tax:.2f}%"
                        else:
                            ret_after_tax_str = "-"
                    else:
                        ret_str = "-"
                        ret_after_tax_str = "-"
                        
                    trade_records.append({
                        'name': name, 'strat': strat, 'gubun': gubun, 'trade_time': trade_time,
                        'b_slip': b_slip_str, 's_slip': s_slip_str, 't_slip': t_slip_str,
                        'ret': ret_str, 'ret_tax': ret_after_tax_str
                    })
                
                # ì‹œê°„ìˆœ ì •ë ¬ (ìµœê·¼ ê²ƒì´ ë§¨ ì•„ë˜ë¡œ ì˜¤ë„ë¡)
                trade_records.sort(key=lambda x: x['trade_time'])
                
                for r in trade_records:
                    row_str = f"{pad(r['name'], 20)}| {pad(r['strat'], 10)}| {pad(r['gubun'], 6)}| {pad(r['trade_time'], 10)}| {pad(r['b_slip'], 10)}| {pad(r['s_slip'], 10)}| {pad(r['t_slip'], 10)}| {pad(r['ret'], 12)}| {pad(r['ret_tax'], 12)}"
                    print(row_str)
                    
        else:
            print("  - ë‹¹ì¼ ì²´ê²° ë‚´ì—­ì´ ì—†ìŠµë‹ˆë‹¤.")
            
        print("=" * 120)
