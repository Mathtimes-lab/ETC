import sys
import time
import os
import math
import pandas as pd  # ë°ì´í„° ì €ì¥/ìˆ˜ì •ìš©
import numpy as np  # ë‚ ì§œ ê³„ì‚°ìš©
from datetime import datetime
from PyQt5.QtWidgets import *
from PyQt5.QAxContainer import *
from PyQt5.QtCore import *


class Kiwoom(QMainWindow):
    def __init__(self):
        super().__init__()

        # --- [ì„¤ì • êµ¬ê°„] ---
        self.BUY_STRATEGY_NAME = "260218ê¸‰ë“±ê¸°ë³¸"
        self.SELL_STRATEGY_NAME = "260218ë§¤ë„ì‹"
        self.CSV_FILE_NAME = "trade_history(real).csv"  # ì €ì¥í•  íŒŒì¼ëª…

        # [ì¶”ê°€] ë§¤ìˆ˜/ë§¤ë„ ê¸ˆì•¡ ë° í˜¸ê°€ ì„¤ì •
        self.MAX_BUY_AMOUNT = 500000  # 1íšŒ ìµœëŒ€ ë§¤ìˆ˜ ê¸ˆì•¡ (ì›)
        self.BUY_ORDER_TYPE = "03"  # ë§¤ìˆ˜ í˜¸ê°€êµ¬ë¶„: "00"(ì§€ì •ê°€), "03"(ì‹œì¥ê°€)
        self.SELL_ORDER_TYPE = "03"  # ë§¤ë„ í˜¸ê°€êµ¬ë¶„: "00"(ì§€ì •ê°€), "03"(ì‹œì¥ê°€)
        # -----------------

        self.account_num = None
        self.bought_today = []  # ì˜¤ëŠ˜ ë§¤ìˆ˜í•œ ì¢…ëª© ë¦¬ìŠ¤íŠ¸

        # ë³´ìœ  ì¢…ëª© ê´€ë¦¬: { 'ì¢…ëª©ì½”ë“œ': {'qty': ìˆ˜ëŸ‰, 'price': ë‹¨ê°€, ...} }
        self.held_stocks = {}

        # ë§¤ìˆ˜ ì£¼ë¬¸ ì‹œì ì˜ ë©”íƒ€ ë°ì´í„° ì„ì‹œ ì €ì¥ (ì²´ê²° ì „ê¹Œì§€ ë³´ê´€)
        self.buy_meta_data = {}

        # [ì‹ ê·œ] TR ìš”ì²­ ë°ì´í„° ì„ì‹œ ì €ì¥ìš© (ë™ê¸° í†µì‹ ìš©)
        self.tr_data_temp = {}

        self.open_buy_orders = {}  # ë¯¸ì²´ê²° ë§¤ìˆ˜ ì£¼ë¬¸ ê´€ë¦¬

        # í˜„ì¬ ì‹¤ì‹œê°„ ì¡°ê±´ ë§Œì¡± ì¢…ëª© ê´€ë¦¬ (ëª¨ë‹ˆí„°ë§ìš©)
        self.current_conditioned_stocks = set()

        # [ì‹ ê·œ] ì‘ì—… ëŒ€ê¸°ì—´(Queue) ì‹œìŠ¤í…œ (TR ê³¼ë¶€í•˜ ë° ê°•ì œì¢…ë£Œ 0xC0000409 ë°©ì§€)
        self.job_queue = []
        self.is_processing_job = False  # ì‘ì—… ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€ìš© ë½(Lock)

        # í‚¤ì›€ OCX ìƒì„±
        self.kiwoom = QAxWidget("KHOPENAPI.KHOpenAPICtrl.1")

        # API íŒì—… ì–µì œ
        self.kiwoom.dynamicCall("KOA_Functions(QString, QString)", "SetShowMessage", "0")

        # ì´ë²¤íŠ¸ ì—°ê²°
        self.kiwoom.OnEventConnect.connect(self._event_connect)
        self.kiwoom.OnReceiveConditionVer.connect(self._handler_condition_load)
        self.kiwoom.OnReceiveTrData.connect(self._handler_tr_data)
        self.kiwoom.OnReceiveMsg.connect(self._handler_msg)

        try:
            self.kiwoom.OnReceiveTrCondition.connect(self._handler_condition)
        except AttributeError:
            self.kiwoom.OnReceiveCondition.connect(self._handler_condition)

        self.kiwoom.OnReceiveRealCondition.connect(self._handler_real_condition)
        self.kiwoom.OnReceiveChejanData.connect(self._handler_chejan_data)

        # ì‹œìŠ¤í…œ ì ê²€ ë° ë¯¸ì²´ê²° ì·¨ì†Œ íƒ€ì´ë¨¸ (1ë¶„)
        self.periodic_timer = QTimer(self)
        self.periodic_timer.timeout.connect(self._periodic_check)
        self.periodic_timer.start(60000)

        # ìŠ¬ë¦¬í”¼ì§€ ë¶„ì„ ë¦¬í¬íŠ¸ íƒ€ì´ë¨¸ (5ë¶„)
        self.slippage_timer = QTimer(self)
        self.slippage_timer.timeout.connect(self._print_slippage_report)
        self.slippage_timer.start(300000)

        # [ìˆ˜ì •] 0xC0000409 ì—ëŸ¬ ë°©ì§€ë¥¼ ìœ„í•´, ë‹¨ë°œì„±(SingleShot) íƒ€ì´ë¨¸ë¡œ í ì²˜ë¦¬ ì‹œì‘
        QTimer.singleShot(1000, self._process_job_queue)

    # -------------------------------------
    # [ìœ í‹¸] ì•ˆì „í•œ ë”œë ˆì´ (GUI/ì´ë²¤íŠ¸ ë©ˆì¶¤ ë°©ì§€)
    # -------------------------------------
    def _safe_delay(self, ms):
        """time.sleep ëŒ€ì‹  ì‚¬ìš©í•˜ì—¬ ì´ë²¤íŠ¸ ë£¨í”„ê°€ ë©ˆì¶”ì§€ ì•Šë„ë¡ í•¨"""
        loop = QEventLoop()
        QTimer.singleShot(ms, loop.quit)
        loop.exec_()

    # -------------------------------------
    # [ìœ í‹¸] ì—‘ì…€ ì»¬ëŸ¼ í•˜ìœ„ í˜¸í™˜ì„± ìœ ì§€ ë° ë§ˆì´ê·¸ë ˆì´ì…˜
    # -------------------------------------
    def _migrate_history_columns(self, df):
        rename_map = {
            '5%ìƒìŠ¹ê°€(ë³´ì •X)': 'ë§¤ìˆ˜ëª©í‘œê°€',
            'ëª©í‘œê°€(ë³´ì •X)': 'ë§¤ìˆ˜ëª©í‘œê°€',
            'ìŠ¬ë¦¬í”¼ì§€(%)': 'ë§¤ìˆ˜ìŠ¬ë¦¬í”¼ì§€(%)',
            'ë§¤ë„ê°€ê²©': 'ì‹¤ì œë§¤ë„ê°€',
            'ìˆ˜ìµë¥ (%)': 'ì‹¤ì œìˆ˜ìµë¥ (%)'
        }
        for old, new in rename_map.items():
            if old in df.columns:
                df = df.rename(columns={old: new})

        # ì‹ ê·œ ì»¬ëŸ¼ì´ ì—†ìœ¼ë©´ ë¹ˆ ë¬¸ìì—´ë¡œ ì¶”ê°€
        for col in ['ë§¤ë„ëª©í‘œê°€', 'ë§¤ë„ìŠ¬ë¦¬í”¼ì§€(%)', 'í•©ì‚°ìŠ¬ë¦¬í”¼ì§€(%)', 'í…ŒìŠ¤íŠ¸ìˆ˜ìµë¥ (%)']:
            if col not in df.columns:
                df[col] = ''

        return df

    # -------------------------------------
    # [ìœ í‹¸] í˜¸ê°€ ë‹¨ìœ„ ê³„ì‚°
    # -------------------------------------
    def _get_hoga_unit(self, price):
        if price < 2000:
            return 1
        elif price < 5000:
            return 5
        elif price < 20000:
            return 10
        elif price < 50000:
            return 50
        elif price < 200000:
            return 100
        elif price < 500000:
            return 500
        else:
            return 1000

    def _adjust_price_to_tick(self, price):
        unit = self._get_hoga_unit(price)
        return int(round(price / unit) * unit)

    # -------------------------------------
    # [í•µì‹¬] CSV ì´ë ¥ ê´€ë¦¬ ë¡œì§
    # -------------------------------------
    def _log_buy_trade(self, code, stock_name, buy_date, buy_time, target_raw, buy_price, slippage):
        """ë§¤ìˆ˜ ì²´ê²° ì‹œ: ì‹ ê·œ í–‰ ìƒì„± (ë§¤ë„ ì •ë³´ëŠ” ê³µë€)"""
        if os.path.exists(self.CSV_FILE_NAME):
            try:
                df_exist = pd.read_csv(self.CSV_FILE_NAME, dtype={'ì¢…ëª©ì½”ë“œ': str})
                df_exist = self._migrate_history_columns(df_exist)

                df_exist['ì¢…ëª©ì½”ë“œ'] = df_exist['ì¢…ëª©ì½”ë“œ'].astype(str).str.replace("'", "").str.zfill(6)
                is_duplicate = not df_exist[
                    (df_exist['ì¢…ëª©ì½”ë“œ'] == code) &
                    (df_exist['ë§¤ìˆ˜ì¼'] == buy_date) &
                    (df_exist['ë§¤ìˆ˜ì‹œê°„'] == buy_time)
                    ].empty
                if is_duplicate:
                    return
            except Exception:
                pass

        new_data = {
            'ì¢…ëª©ì½”ë“œ': f"'{code}",
            'ì¢…ëª©ëª…': stock_name,
            'ë§¤ìˆ˜ì¼': buy_date,
            'ë§¤ìˆ˜ì‹œê°„': buy_time,
            'ë§¤ìˆ˜ëª©í‘œê°€': int(target_raw),
            'ì‹¤ì œë§¤ì…ê°€': buy_price,
            'ë§¤ìˆ˜ìŠ¬ë¦¬í”¼ì§€(%)': round(slippage, 2),
            'ë§¤ë„ì¼': '',
            'ë§¤ë„ì‹œê°„': '',
            'ë§¤ë„ëª©í‘œê°€': '',
            'ì‹¤ì œë§¤ë„ê°€': '',
            'ë§¤ë„ìŠ¬ë¦¬í”¼ì§€(%)': '',
            'í•©ì‚°ìŠ¬ë¦¬í”¼ì§€(%)': '',
            'í…ŒìŠ¤íŠ¸ìˆ˜ìµë¥ (%)': '',
            'ì‹¤ì œìˆ˜ìµë¥ (%)': '',
            'ë³´ìœ ê¸°ê°„(ì¼)': ''
        }

        try:
            df_new = pd.DataFrame([new_data])
            if not os.path.exists(self.CSV_FILE_NAME):
                df_new.to_csv(self.CSV_FILE_NAME, index=False, encoding='utf-8-sig')
            else:
                df_new.to_csv(self.CSV_FILE_NAME, mode='a', header=False, index=False, encoding='utf-8-sig')
            print(f"[ê¸°ë¡] ë§¤ìˆ˜ ì´ë ¥ ì €ì¥ ì™„ë£Œ: {stock_name}")
        except Exception as e:
            print(f"[ì˜¤ë¥˜] ë§¤ìˆ˜ ê¸°ë¡ ì €ì¥ ì‹¤íŒ¨: {e}")

    def _log_sell_trade(self, code, stock_name, sell_date, sell_time, sell_target_price, actual_sell_price):
        """ë§¤ë„ ì²´ê²° ì‹œ: ê¸°ì¡´ í–‰ì„ ì°¾ì•„ ë§¤ë„ ì •ë³´ ì—…ë°ì´íŠ¸"""
        if not os.path.exists(self.CSV_FILE_NAME):
            print(f"[ì˜¤ë¥˜] ë§¤ë§¤ ê¸°ë¡ íŒŒì¼ì´ ì—†ì–´ ë§¤ë„ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {stock_name}")
            return

        try:
            df = pd.read_csv(self.CSV_FILE_NAME, dtype={'ì¢…ëª©ì½”ë“œ': str})
            df = self._migrate_history_columns(df)

            df['ì¢…ëª©ì½”ë“œ_ìˆœìˆ˜'] = df['ì¢…ëª©ì½”ë“œ'].astype(str).str.replace("'", "").str.zfill(6)
            mask = (df['ì¢…ëª©ì½”ë“œ_ìˆœìˆ˜'] == code) & (df['ë§¤ë„ì¼'].isna() | (df['ë§¤ë„ì¼'] == ''))

            if not df.loc[mask].empty:
                idx = df.loc[mask].index[-1]

                # ê¸°ì¡´ ë°ì´í„° ì¶”ì¶œ (ì—ëŸ¬ ë°©ì§€ìš© ì˜ˆì™¸ì²˜ë¦¬)
                try:
                    buy_target = float(df.loc[idx, 'ë§¤ìˆ˜ëª©í‘œê°€'])
                except:
                    buy_target = float(df.loc[idx, 'ì‹¤ì œë§¤ì…ê°€'])

                try:
                    buy_price = float(df.loc[idx, 'ì‹¤ì œë§¤ì…ê°€'])
                except:
                    buy_price = 0.0

                try:
                    buy_slippage = float(df.loc[idx, 'ë§¤ìˆ˜ìŠ¬ë¦¬í”¼ì§€(%)'])
                except:
                    buy_slippage = 0.0

                buy_date = str(df.loc[idx, 'ë§¤ìˆ˜ì¼'])

                try:
                    hold_days = np.busday_count(buy_date, sell_date)
                except:
                    hold_days = 0

                # ìŠ¬ë¦¬í”¼ì§€ ë° ìˆ˜ìµë¥  ê³„ì‚° ë¡œì§
                sell_slippage = ((
                                             sell_target_price - actual_sell_price) / sell_target_price * 100) if sell_target_price > 0 else 0.0
                total_slippage = buy_slippage + sell_slippage

                test_return = ((sell_target_price - buy_target) / buy_target * 100) if buy_target > 0 else 0.0
                actual_return = ((actual_sell_price - buy_price) / buy_price * 100) if buy_price > 0 else 0.0

                df.loc[idx, 'ë§¤ë„ì¼'] = sell_date
                df.loc[idx, 'ë§¤ë„ì‹œê°„'] = sell_time
                df.loc[idx, 'ë§¤ë„ëª©í‘œê°€'] = int(sell_target_price)
                df.loc[idx, 'ì‹¤ì œë§¤ë„ê°€'] = int(actual_sell_price)
                df.loc[idx, 'ë§¤ë„ìŠ¬ë¦¬í”¼ì§€(%)'] = round(sell_slippage, 2)
                df.loc[idx, 'í•©ì‚°ìŠ¬ë¦¬í”¼ì§€(%)'] = round(total_slippage, 2)
                df.loc[idx, 'í…ŒìŠ¤íŠ¸ìˆ˜ìµë¥ (%)'] = round(test_return, 2)
                df.loc[idx, 'ì‹¤ì œìˆ˜ìµë¥ (%)'] = round(actual_return, 2)
                df.loc[idx, 'ë³´ìœ ê¸°ê°„(ì¼)'] = hold_days

                df = df.drop(columns=['ì¢…ëª©ì½”ë“œ_ìˆœìˆ˜'])
                df.to_csv(self.CSV_FILE_NAME, index=False, encoding='utf-8-sig')
                print(f"[ê¸°ë¡] ë§¤ë„ ì´ë ¥ ì—…ë°ì´íŠ¸ ì™„ë£Œ: {stock_name} (ì‹¤ì œìˆ˜ìµë¥ : {actual_return:.2f}%)")
            else:
                print(f"[ì•Œë¦¼] '{stock_name}'ì˜ ë§¤ìˆ˜ ê¸°ë¡ì„ ì°¾ì„ ìˆ˜ ì—†ì–´ ë§¤ë„ ê¸°ë¡ë§Œ ë³„ë„ë¡œ ë‚¨ê¸¸ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")

        except Exception as e:
            print(f"[ì˜¤ë¥˜] ë§¤ë„ ê¸°ë¡ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")

    def _update_csv_target_price(self, code, target_price, order_type):
        """ì‚¬í›„ì— ê³„ì‚°ëœ ë°±í…ŒìŠ¤íŠ¸ ëª©í‘œê°€ë¥¼ ì—‘ì…€ì— ì—…ë°ì´íŠ¸í•˜ëŠ” ë¡œì§ (ì£¼ë¬¸ ì§€ì—° ë°©ì§€ìš©)"""
        if not os.path.exists(self.CSV_FILE_NAME): return
        try:
            df = pd.read_csv(self.CSV_FILE_NAME, dtype={'ì¢…ëª©ì½”ë“œ': str})
            df['ì¢…ëª©ì½”ë“œ_ìˆœìˆ˜'] = df['ì¢…ëª©ì½”ë“œ'].astype(str).str.replace("'", "").str.zfill(6)

            if order_type == 'BUY':
                # ë§¤ë„ì¼ì´ ë¹„ì–´ìˆëŠ”(í˜„ì¬ ì§„í–‰ì¤‘ì¸) í•´ë‹¹ ì¢…ëª©ì˜ ë§¤ìˆ˜ëª©í‘œê°€ ì—…ë°ì´íŠ¸
                mask = (df['ì¢…ëª©ì½”ë“œ_ìˆœìˆ˜'] == code) & (df['ë§¤ë„ì¼'].isna() | (df['ë§¤ë„ì¼'] == ''))
                if not df.loc[mask].empty:
                    idx = df.loc[mask].index[-1]
                    df.loc[idx, 'ë§¤ìˆ˜ëª©í‘œê°€'] = int(target_price)

                    buy_price = float(df.loc[idx, 'ì‹¤ì œë§¤ì…ê°€'])
                    if target_price > 0:
                        df.loc[idx, 'ë§¤ìˆ˜ìŠ¬ë¦¬í”¼ì§€(%)'] = round(((buy_price - target_price) / target_price) * 100, 2)

                    df = df.drop(columns=['ì¢…ëª©ì½”ë“œ_ìˆœìˆ˜'])
                    df.to_csv(self.CSV_FILE_NAME, index=False, encoding='utf-8-sig')

            elif order_type == 'SELL':
                # ë§¤ë„ì¼ì´ ì í˜€ìˆëŠ” ê°€ì¥ ìµœê·¼ í–‰ì˜ ë§¤ë„ëª©í‘œê°€ ì—…ë°ì´íŠ¸
                mask = (df['ì¢…ëª©ì½”ë“œ_ìˆœìˆ˜'] == code)
                if not df.loc[mask].empty:
                    idx = df.loc[mask].index[-1]
                    df.loc[idx, 'ë§¤ë„ëª©í‘œê°€'] = int(target_price)

                    actual_sell = float(df.loc[idx, 'ì‹¤ì œë§¤ë„ê°€'])
                    if target_price > 0:
                        sell_slip = ((target_price - actual_sell) / target_price) * 100
                        df.loc[idx, 'ë§¤ë„ìŠ¬ë¦¬í”¼ì§€(%)'] = round(sell_slip, 2)

                        try:
                            buy_slip = float(df.loc[idx, 'ë§¤ìˆ˜ìŠ¬ë¦¬í”¼ì§€(%)'])
                        except:
                            buy_slip = 0.0
                        df.loc[idx, 'í•©ì‚°ìŠ¬ë¦¬í”¼ì§€(%)'] = round(buy_slip + sell_slip, 2)

                        try:
                            buy_target = float(df.loc[idx, 'ë§¤ìˆ˜ëª©í‘œê°€'])
                        except:
                            buy_target = float(df.loc[idx, 'ì‹¤ì œë§¤ì…ê°€'])
                        if buy_target > 0:
                            df.loc[idx, 'í…ŒìŠ¤íŠ¸ìˆ˜ìµë¥ (%)'] = round(((target_price - buy_target) / buy_target) * 100, 2)

                    df = df.drop(columns=['ì¢…ëª©ì½”ë“œ_ìˆœìˆ˜'])
                    df.to_csv(self.CSV_FILE_NAME, index=False, encoding='utf-8-sig')
        except Exception as e:
            pass

    # -------------------------------------
    # ì´ˆê¸°í™” ì²´ì¸
    # -------------------------------------
    def _req_outstanding_orders(self):
        print("[ì‹œìŠ¤í…œ] ë¯¸ì²´ê²° ì£¼ë¬¸ ë‚´ì—­ì„ í™•ì¸í•©ë‹ˆë‹¤...")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ê³„ì¢Œë²ˆí˜¸", self.account_num)
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ì „ì²´ì¢…ëª©êµ¬ë¶„", "0")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ë§¤ë§¤êµ¬ë¶„", "0")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ì²´ê²°êµ¬ë¶„", "1")
        self.kiwoom.dynamicCall("CommRqData(QString, QString, int, QString)", "ë¯¸ì²´ê²°ìš”ì²­", "opt10075", 0, "0102")

    def _req_account_balance(self):
        print("[ì‹œìŠ¤í…œ] ë³´ìœ  ì¢…ëª©(ê³„ì¢Œ ì”ê³ )ì„ í™•ì¸í•©ë‹ˆë‹¤...")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ê³„ì¢Œë²ˆí˜¸", self.account_num)
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ë¹„ë°€ë²ˆí˜¸", "")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ë¹„ë°€ë²ˆí˜¸ì…ë ¥ë§¤ì²´êµ¬ë¶„", "00")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ì¡°íšŒêµ¬ë¶„", "2")
        self.kiwoom.dynamicCall("CommRqData(QString, QString, int, QString)", "ì”ê³ ìš”ì²­", "opw00018", 0, "0103")

    def _get_stock_info(self, code):
        """TRìš”ì²­(opt10081)ìœ¼ë¡œ ë‹¹ì¼ ì‹œê°€ ë° ê³¼ê±° ì¼ë´‰(4ì¼ì¹˜) ë°ì´í„° í™•ì¸ (Sync)"""
        self.tr_data_temp = {}
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ì¢…ëª©ì½”ë“œ", code)
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ê¸°ì¤€ì¼ì", "")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "ìˆ˜ì •ì£¼ê°€êµ¬ë¶„", "1")
        res = self.kiwoom.dynamicCall("CommRqData(QString, QString, int, QString)", "ì£¼ì‹ì¼ë´‰ê¸°ë³¸ìš”ì²­", "opt10081", 0, "0104")

        if res != 0:
            print(f"[ì‹œìŠ¤í…œ] ì„œë²„ ê³¼ë¶€í•˜ë¡œ ì£¼ì‹ì¼ë´‰ê¸°ë³¸ìš”ì²­(opt10081) ì°¨ë‹¨ë¨ (ì—ëŸ¬ì½”ë“œ: {res})")
            return self.tr_data_temp

        self.tr_event_loop = QEventLoop()
        QTimer.singleShot(3000, self.tr_event_loop.quit)
        self.tr_event_loop.exec_()

        return self.tr_data_temp

    def _handler_tr_data(self, scr_no, rqname, trcode, recordname, prev_next, data_len, err_code, msg, splm_msg):
        if rqname == "ë¯¸ì²´ê²°ìš”ì²­":
            cnt = self.kiwoom.dynamicCall("GetRepeatCnt(QString, QString)", trcode, rqname)
            for i in range(cnt):
                code = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, i,
                                               "ì¢…ëª©ì½”ë“œ").strip()
                order_no = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, i,
                                                   "ì£¼ë¬¸ë²ˆí˜¸").strip()
                order_type = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, i,
                                                     "ì£¼ë¬¸êµ¬ë¶„").strip()
                if "ë§¤ìˆ˜" in order_type:
                    self.open_buy_orders[code] = order_no
            print(f"[ì‹œìŠ¤í…œ] ë¯¸ì²´ê²° ë§¤ìˆ˜ ì£¼ë¬¸ ë³µì›: {len(self.open_buy_orders)}ê±´")
            QTimer.singleShot(200, self._req_account_balance)

        elif rqname == "ì”ê³ ìš”ì²­":
            history_df = pd.DataFrame()
            if os.path.exists(self.CSV_FILE_NAME):
                try:
                    history_df = pd.read_csv(self.CSV_FILE_NAME, dtype={'ì¢…ëª©ì½”ë“œ': str})
                    history_df = self._migrate_history_columns(history_df)
                    history_df['ì¢…ëª©ì½”ë“œ'] = history_df['ì¢…ëª©ì½”ë“œ'].astype(str).str.replace("'", "").str.zfill(6)
                except Exception:
                    pass

            cnt = self.kiwoom.dynamicCall("GetRepeatCnt(QString, QString)", trcode, rqname)
            for i in range(cnt):
                code = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, i,
                                               "ì¢…ëª©ë²ˆí˜¸").strip()
                code = code.replace("A", "")

                qty = int(self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, i,
                                                  "ë³´ìœ ìˆ˜ëŸ‰").strip())
                price = int(self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, i,
                                                    "ë§¤ì…ê°€").strip())

                if qty > 0:
                    target_raw = 0
                    buy_date = ''
                    buy_time = ''
                    csv_buy_price = price
                    csv_slippage = 0.0
                    is_restored_from_csv = False

                    # [ìˆ˜ì •] 1. ì—‘ì…€ íŒŒì¼ì´ ì¡´ì¬í•˜ë©´ ë¬´ì¡°ê±´ ì—‘ì…€ì— ì íŒ ì›ë³¸ ë§¤ìˆ˜ì¼/ëª©í‘œê°€ë¥¼ ê·¸ëŒ€ë¡œ ì‹ ë¢°í•˜ê³  ê°€ì ¸ì˜´
                    if not history_df.empty:
                        mask = (history_df['ì¢…ëª©ì½”ë“œ'] == code) & (history_df['ë§¤ë„ì¼'].isna() | (history_df['ë§¤ë„ì¼'] == ''))
                        if not history_df.loc[mask].empty:
                            last_idx = history_df.loc[mask].index[-1]
                            try:
                                target_raw = int(history_df.loc[last_idx, 'ë§¤ìˆ˜ëª©í‘œê°€'])
                                buy_date = str(history_df.loc[last_idx, 'ë§¤ìˆ˜ì¼'])
                                buy_time = str(history_df.loc[last_idx, 'ë§¤ìˆ˜ì‹œê°„'])
                                csv_buy_price = float(history_df.loc[last_idx, 'ì‹¤ì œë§¤ì…ê°€'])
                                csv_slippage = float(history_df.loc[last_idx, 'ë§¤ìˆ˜ìŠ¬ë¦¬í”¼ì§€(%)'])
                                is_restored_from_csv = True
                            except Exception:
                                pass

                    # [ìˆ˜ì •] 2. ì—‘ì…€ì— ë°ì´í„°ê°€ ì•„ì˜ˆ ì—†ëŠ” ì¢…ëª©ì˜ ê²½ìš° (ì˜ˆ: ìˆ˜ë™ ë§¤ìˆ˜, íƒ€ í”„ë¡œê·¸ë¨ ë§¤ìˆ˜ ë“±)
                    # ì˜¤ëŠ˜ ê°€ê²©ì„ ë°”íƒ•ìœ¼ë¡œ ëª©í‘œê°€ë¥¼ ì–µì§€ë¡œ ê³„ì‚°í•˜ì§€ ì•Šê³ , ë§¤ì…ê°€ = ëª©í‘œê°€ë¡œ í†µì¼ì‹œì¼œ í†µê³„ ì™œê³¡ì„ ì›ì²œ ì°¨ë‹¨í•¨
                    if not is_restored_from_csv:
                        target_raw = price
                        csv_slippage = 0.0
                        buy_date = 'ìˆ˜ë™ë§¤ìˆ˜(ê¸°ë¡ì—†ìŒ)'
                        buy_time = '00:00:00'

                        stock_name = self.kiwoom.dynamicCall("GetMasterCodeName(QString)", code)
                        self._log_buy_trade(code, stock_name, buy_date, buy_time, target_raw, price, csv_slippage)

                    self.held_stocks[code] = {
                        'qty': qty, 'price': price, 'buy_date': buy_date, 'buy_time': buy_time,
                        'target_raw': target_raw, 'type': 'ì§€ì •ê°€',
                        'csv_buy_price': csv_buy_price,
                        'csv_slippage': csv_slippage
                    }

            print(f"[ì‹œìŠ¤í…œ] ë³´ìœ  ì¢…ëª© ë¦¬ìŠ¤íŠ¸ ë³µì›: {len(self.held_stocks)}ì¢…ëª©")
            self._print_slippage_report()
            QTimer.singleShot(200, self._get_condition_load)

        elif rqname == "ì£¼ì‹ì¼ë´‰ê¸°ë³¸ìš”ì²­":
            cnt = self.kiwoom.dynamicCall("GetRepeatCnt(QString, QString)", trcode, rqname)

            op = 0
            pc = 0
            c_list = []

            if cnt > 0:
                open_price = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, 0,
                                                     "ì‹œê°€").strip()
                op = abs(int(open_price)) if open_price else 0

                if cnt > 1:
                    prev_close = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname,
                                                         1, "í˜„ì¬ê°€").strip()
                    pc = abs(int(prev_close)) if prev_close else 0

                # ì „ì¼(1)ë¶€í„° 4ì¼ì „(4)ê¹Œì§€ ì¼ë´‰ ì¢…ê°€ ìˆ˜ì§‘ (ì •ë°°ì—´ ì „í™˜ê°€ ê³„ì‚°ìš©)
                for i in range(1, min(cnt, 5)):
                    close_price = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname,
                                                          i, "í˜„ì¬ê°€").strip()
                    c_list.append(abs(int(close_price)) if close_price else 0)

            self.tr_data_temp = {
                'open': op,
                'prev': pc,
                'c_list': c_list
            }
            if hasattr(self, 'tr_event_loop') and self.tr_event_loop.isRunning():
                self.tr_event_loop.quit()

    # -------------------------------------
    # ë©”ì¸ ë¡œì§
    # -------------------------------------
    def _execute_buy(self, code):
        now = datetime.now().strftime('%H:%M:%S')
        stock_name = self.kiwoom.dynamicCall("GetMasterCodeName(QString)", code)

        if code in self.open_buy_orders:
            print(f"[{now}] [ë§¤ìˆ˜ìŠ¤í‚µ] {stock_name}({code}) - ë¯¸ì²´ê²° ë§¤ìˆ˜ ì£¼ë¬¸ ëŒ€ê¸° ì¤‘")
            return

        if code in self.held_stocks:
            print(f"[{now}] [ë§¤ìˆ˜ìŠ¤í‚µ] {stock_name}({code}) - ì´ë¯¸ ë³´ìœ  ì¤‘ì¸ ì¢…ëª©")
            return

        if code in self.bought_today:
            return

        # 1. ì§€ì—° ì—†ëŠ” ì¦‰ì‹œ ì£¼ë¬¸ì„ ìœ„í•´ ì„œë²„ í†µì‹  ì—†ì´ 'í˜„ì¬ê°€' ë°”ë¡œ ë©”ëª¨ë¦¬ ì¡°íšŒ (0ì´ˆ ì†Œìš”)
        current_price_str = self.kiwoom.dynamicCall("GetMasterLastPrice(QString)", code)
        current_price = abs(int(current_price_str)) if current_price_str else 0

        if current_price == 0:
            print(f"[{now}] [ë§¤ìˆ˜ë¶ˆê°€] {stock_name}({code}) - í˜„ì¬ê°€ ì¡°íšŒ ë¶ˆê°€")
            return

        quantity = self.MAX_BUY_AMOUNT // current_price
        if quantity == 0:
            print(f"[{now}] [ë§¤ìˆ˜ë¶ˆê°€] {stock_name}({code}) - ë‹¨ê°€ ì´ˆê³¼")
            return

        # [ì£¼ë¬¸ ì„ (å…ˆ) ì‹¤í–‰] ê³„ì‚° ì§€ì—°ìœ¼ë¡œ ì¸í•œ ìˆ˜ìµë¥  í•˜ë½ ë°©ì§€
        print(f"[{now}] ğŸš€ [ìë™ë§¤ìˆ˜] {stock_name}({code}) {quantity}ì£¼ ì¦‰ì‹œ ì‹œì¥ê°€ ì£¼ë¬¸ ë°œì†¡!")
        self.buy_meta_data[code] = {'target_raw': 0, 'time': now}  # ëª©í‘œê°€ëŠ” ì„ì‹œ 0 ì„¸íŒ…
        self._send_order(code, 1, quantity, 0)

        if code not in self.bought_today: self.bought_today.append(code)

        # 2. ì£¼ë¬¸ì´ ì„œë²„ë¡œ ë‚ ì•„ê°„ í›„ ì—¬ìœ ë¡­ê²Œ ë°±í…ŒìŠ¤íŠ¸ ëª©í‘œê°€ ê³„ì‚° (0.2~0.5ì´ˆ ì†Œìš”)
        try:
            info = self._get_stock_info(code)
            open_price = info.get('open', current_price)
            prev_price = info.get('prev', current_price)
            c_list = info.get('c_list', [])

            target_price = math.ceil(prev_price * 1.05)
            golden_cross_price = 0
            if len(c_list) >= 4:
                c_1, c_2, c_3, c_4 = c_list[0], c_list[1], c_list[2], c_list[3]
                golden_cross_price = math.ceil(1.5 * (c_3 + c_4) - (c_1 + c_2))

            buy_req_price = max(target_price, golden_cross_price)
            target_raw_int = int(open_price) if open_price > buy_req_price else int(buy_req_price)

            # 3. ì‚¬í›„ ì—‘ì…€ ë° ë©”ëª¨ë¦¬ ì—…ë°ì´íŠ¸
            self.buy_meta_data[code]['target_raw'] = target_raw_int
            print(f"  > (ì‚¬í›„ê¸°ë¡) ë°±í…ŒìŠ¤íŠ¸ ë§¤ìˆ˜ëª©í‘œê°€ ì‚°ì¶œ ì™„ë£Œ: {target_raw_int:,}ì› (ì—‘ì…€ ìë™ ë°˜ì˜)")

            self._update_csv_target_price(code, target_raw_int, 'BUY')

            if code in self.held_stocks:
                self.held_stocks[code]['target_raw'] = target_raw_int
                if target_raw_int > 0:
                    buy_price = self.held_stocks[code]['csv_buy_price']
                    self.held_stocks[code]['csv_slippage'] = ((buy_price - target_raw_int) / target_raw_int) * 100

        except Exception as e:
            print(f"[{now}] [ì˜¤ë¥˜] ê°€ê²©ì •ë³´ ì‚¬í›„ ì¡°íšŒ ì‹¤íŒ¨: {code} ({e})")

    def _execute_sell(self, code):
        now = datetime.now().strftime('%H:%M:%S')
        stock_name = self.kiwoom.dynamicCall("GetMasterCodeName(QString)", code)

        if code in self.bought_today:
            print(f"[{now}] [ë§¤ë„ìŠ¤í‚µ] {stock_name} - ë‹¹ì¼ ë§¤ìˆ˜ ì¢…ëª©")
            return

        if code in self.held_stocks and self.held_stocks[code]['qty'] > 0:
            quantity = self.held_stocks[code]['qty']

            # 1. ì§€ì—°ì‹œê°„ 0ì´ˆë¡œ ë¬»ì§€ë„ ë”°ì§€ì§€ë„ ì•Šê³  ì¦‰ì‹œ ì‹œì¥ê°€ ë§¤ë„ ë°œì†¡
            print(f"[{now}] ğŸš€ [ìë™ë§¤ë„] {stock_name} {quantity}ì£¼ ì¦‰ì‹œ ì‹œì¥ê°€ ë§¤ë„ ë°œì†¡!")
            self._send_order(code, 2, quantity, 0)

            # 2. ì£¼ë¬¸ì´ ì„œë²„ë¡œ ë‚ ì•„ê°„ í›„ ì—¬ìœ ë¡­ê²Œ ì—‘ì…€ ê¸°ë¡ìš© ë°±í…ŒìŠ¤íŠ¸ ë§¤ë„ëª©í‘œê°€ ê³„ì‚°
            info = self._get_stock_info(code)
            c_list = info.get('c_list', [])
            open_price = info.get('open', 0)

            sell_target_price = 0
            if len(c_list) >= 4:
                c_1, c_2, c_3, c_4 = c_list[0], c_list[1], c_list[2], c_list[3]
                cross_price = round(1.5 * (c_3 + c_4) - (c_1 + c_2))

                if 0 < open_price < cross_price:
                    sell_target_price = open_price
                else:
                    sell_target_price = cross_price

            if sell_target_price == 0:
                current_price_str = self.kiwoom.dynamicCall("GetMasterLastPrice(QString)", code)
                sell_target_price = abs(int(current_price_str)) if current_price_str else 0

            self.held_stocks[code]['sell_target_price'] = sell_target_price
            print(f"  > (ì‚¬í›„ê¸°ë¡) ë°±í…ŒìŠ¤íŠ¸ ë§¤ë„ëª©í‘œê°€ ì‚°ì¶œ ì™„ë£Œ: {sell_target_price:,}ì› (ì—‘ì…€ ìë™ ë°˜ì˜)")

            # 3. ì‚¬í›„ ì—‘ì…€ ì—…ë°ì´íŠ¸
            self._update_csv_target_price(code, sell_target_price, 'SELL')

        else:
            print(f"[{now}] [ë§¤ë„ë¶ˆê°€] {stock_name} - ì”ê³  ì—†ìŒ")

    # -------------------------------------
    # ì‘ì—… í ì²˜ë¦¬ (ë‹¨ë°œì„± ì¬ê·€ í˜¸ì¶œ ë°©ì‹, ë°ë“œë½ ë°©ì§€)
    # -------------------------------------
    def _process_job_queue(self):
        """íì—ì„œ ì‘ì—…ì„ êº¼ë‚´ì–´ ìˆœì°¨ ì²˜ë¦¬ (ì•ˆì •ì„± í™•ë³´)"""
        # í†µì‹  ì‘ì—…ì´ ì§„í–‰ ì¤‘ì´ë©´, 0.2ì´ˆ ë’¤ì— ë‹¤ì‹œ í™•ì¸
        if self.is_processing_job:
            QTimer.singleShot(200, self._process_job_queue)
            return

        # ëŒ€ê¸° ì¤‘ì¸ ì‘ì—…ì´ ì—†ìœ¼ë©´ 0.5ì´ˆ ë’¤ì— ë‹¤ì‹œ í™•ì¸
        if not self.job_queue:
            QTimer.singleShot(500, self._process_job_queue)
            return

        self.is_processing_job = True  # ë¬¸ ì ê¸ˆ (ë‹¤ë¥¸ í†µì‹  ê°œì… ì°¨ë‹¨)

        try:
            job = self.job_queue.pop(0)
            job_type = job['type']
            code = job['code']

            if job_type == 'BUY':
                self._execute_buy(code)
            elif job_type == 'SELL':
                self._execute_sell(code)
        finally:
            self.is_processing_job = False  # ì‘ì—… ì™„ì „ ì¢…ë£Œ í›„ ë¬¸ ì—´ë¦¼
            QTimer.singleShot(300, self._process_job_queue)

    # -------------------------------------
    # ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
    # -------------------------------------
    def comm_connect(self):
        print("[ì‹œìŠ¤í…œ] ë¡œê·¸ì¸ ì‹œë„...")
        self.kiwoom.dynamicCall("CommConnect()")
        self.login_event_loop = QEventLoop()
        self.login_event_loop.exec_()

    def _event_connect(self, err_code):
        if err_code == 0:
            print("ë¡œê·¸ì¸ ì„±ê³µ!")
            self.kiwoom.dynamicCall("KOA_Functions(QString, QString)", "SetShowMessage", "0")

            self._get_account_info()
            QTimer.singleShot(200, self._req_outstanding_orders)
        else:
            print("ë¡œê·¸ì¸ ì‹¤íŒ¨")
            self.login_event_loop.exit()

    def _handler_msg(self, scr_no, rqname, trcode, msg):
        if "ë§¤ìˆ˜" in rqname or "ì£¼ë¬¸" in msg:
            print(f"[ì„œë²„ë©”ì‹œì§€] {msg}")
        # [ì¶”ê°€] ê³¼ë¶€í•˜ ë“± ì‹œìŠ¤í…œ ê²½ê³ ì„± ë©”ì‹œì§€ë„ í‘œì‹œí•˜ì—¬ ì›ì¸ íŒŒì•… ìš©ì´
        elif "ì¡°íšŒ" in msg or "ì´ˆê³¼" in msg or "ì œí•œ" in msg:
            print(f"[ì„œë²„ê²½ê³ ] {msg}")

    def after_login(self):
        self.login_event_loop.exit()

    def _get_account_info(self):
        self.account_num = self.kiwoom.dynamicCall("GetLoginInfo(QString)", "ACCNO").split(';')[0]
        print(f"[ë‚´ ì •ë³´] ê³„ì¢Œë²ˆí˜¸: {self.account_num}")

    def _get_condition_load(self):
        self.kiwoom.dynamicCall("GetConditionLoad()")

    def _handler_condition_load(self, ret, msg):
        if ret == 1:
            print("[ì‹œìŠ¤í…œ] ì¡°ê±´ì‹ ë¡œë”© ì™„ë£Œ.")
            conditions = self.kiwoom.dynamicCall("GetConditionNameList()").split(";")[:-1]
            for c in conditions:
                idx, name = c.split('^')
                if name in [self.BUY_STRATEGY_NAME, self.SELL_STRATEGY_NAME]:
                    print(f"[{name}] ì´ˆê¸° ê²€ìƒ‰ ë° ì‹¤ì‹œê°„ ê°ì‹œ ìš”ì²­...")
                    # [ìˆ˜ì •] ì˜µì…˜ì„ 0(1íšŒì„±)ì—ì„œ 1(ì‹¤ì‹œê°„)ë¡œ ë³€ê²½í•˜ì—¬ ì²˜ìŒë¶€í„° ì‹¤ì‹œê°„ ê°ì‹œë¥¼ í™•ì‹¤íˆ ì¼¬
                    self.kiwoom.dynamicCall("SendCondition(QString, QString, int, int)",
                                            "0156" if "ë§¤ìˆ˜" in name else "0157", name, int(idx), 1)
                    self._safe_delay(1500)

    def _handler_condition(self, scr_no, code_list, cond_name, cond_index, next):
        now = datetime.now().strftime('%H:%M:%S')
        codes = code_list.split(';')[:-1] if code_list else []
        print(f"\n[{now}] [{cond_name}] ê²€ìƒ‰ ê²°ê³¼: {len(codes)}ì¢…ëª©")

        if cond_name.strip() == self.SELL_STRATEGY_NAME.strip():
            sell_targets = [c for c in codes if c in self.held_stocks]
            if sell_targets:
                print(f"  > [ë§¤ë„ëŒ€ìƒë°œê²¬] ì”ê³  ì¤‘ ë§¤ë„ ì¡°ê±´ ì¼ì¹˜: {len(sell_targets)}ì¢…ëª© ë°œê²¬ (íì— ëŒ€ê¸° ë“±ë¡)")
                for code in sell_targets:
                    self.job_queue.append({'type': 'SELL', 'code': code})
            else:
                print(f"  > [ë§¤ë„ëŒ€ìƒì—†ìŒ] ê²€ìƒ‰ëœ ì¢…ëª© ì¤‘ í˜„ì¬ ì”ê³ ì— ë³´ìœ í•œ ì¢…ëª©ì´ ì—†ìŠµë‹ˆë‹¤.")

        elif cond_name.strip() == self.BUY_STRATEGY_NAME.strip():
            for code in codes:
                self.current_conditioned_stocks.add(code)
                self.job_queue.append({'type': 'BUY', 'code': code})

        # [ìˆ˜ì •] í†µì‹ ì´ ì°¨ë‹¨ë˜ëŠ” ì›ì¸ì´ì—ˆë˜ ì¤‘ë³µ ì‹¤ì‹œê°„ ì „í™˜ ìš”ì²­(SendCondition) ì½”ë“œ ì‚­ì œ ì™„ë£Œ

    def _handler_real_condition(self, code, type, cond_name, cond_index):
        if type == 'I':
            if cond_name.strip() == self.BUY_STRATEGY_NAME.strip():
                self.current_conditioned_stocks.add(code)
                self.job_queue.append({'type': 'BUY', 'code': code})
            elif cond_name.strip() == self.SELL_STRATEGY_NAME.strip():
                self.job_queue.append({'type': 'SELL', 'code': code})
        elif type == 'D' and cond_name.strip() == self.BUY_STRATEGY_NAME.strip():
            self.current_conditioned_stocks.discard(code)

    def _send_order(self, code, order_type, quantity, price, order_no=""):
        if order_type == 1:  # ì‹ ê·œë§¤ìˆ˜
            hoga = self.BUY_ORDER_TYPE
            if hoga == "03": price = 0  # ì‹œì¥ê°€ëŠ” ê°€ê²© 0 ì „ì†¡
        elif order_type == 2:  # ì‹ ê·œë§¤ë„
            hoga = self.SELL_ORDER_TYPE
            if hoga == "03":
                price = 0
            elif hoga == "00" and price == 0:
                # ë§¤ë„ì‹œ ì§€ì •ê°€ë¡œ ì„¤ì •í–ˆëŠ”ë° ê°€ê²©ì´ 0ìœ¼ë¡œ ë„˜ì–´ì™”ì„ ê²½ìš° í˜„ì¬ê°€ë¡œ ë³´ì •
                current_price_str = self.kiwoom.dynamicCall("GetMasterLastPrice(QString)", code)
                price = abs(int(current_price_str)) if current_price_str else 0
        else:  # ë§¤ìˆ˜ì·¨ì†Œ ë“± ê¸°íƒ€
            hoga = "00"

        self.kiwoom.dynamicCall("SendOrder(QString, QString, QString, int, QString, int, int, QString, QString)",
                                ["send_order", "0101", self.account_num, order_type, code, quantity, price, hoga,
                                 order_no])

    def _handler_chejan_data(self, gubun, item_cnt, fid_list):
        if gubun == '0':  # ì ‘ìˆ˜/ì²´ê²°
            status = self.kiwoom.dynamicCall("GetChejanData(int)", 913)
            code = self.kiwoom.dynamicCall("GetChejanData(int)", 9001).replace('A', '').strip()
            order_no = self.kiwoom.dynamicCall("GetChejanData(int)", 9203)
            order_type = self.kiwoom.dynamicCall("GetChejanData(int)", 905)

            if "ë§¤ìˆ˜" in order_type:
                if status == "ì ‘ìˆ˜":
                    self.open_buy_orders[code] = order_no
                elif status == "ì²´ê²°":
                    if code in self.open_buy_orders: del self.open_buy_orders[code]

                    if code not in self.held_stocks:
                        buy_price = int(self.kiwoom.dynamicCall("GetChejanData(int)", 910))
                        stock_name = self.kiwoom.dynamicCall("GetMasterCodeName(QString)", code)
                        today = datetime.now().strftime('%Y-%m-%d')
                        now_time = datetime.now().strftime('%H:%M:%S')

                        target_raw = 0
                        if code in self.buy_meta_data: target_raw = self.buy_meta_data[code]['target_raw']

                        slippage = 0
                        if target_raw > 0:
                            slippage = ((buy_price - target_raw) / target_raw) * 100

                        self._log_buy_trade(code, stock_name, today, now_time, target_raw, buy_price, slippage)

                        self.held_stocks[code] = {
                            'qty': 0, 'price': buy_price, 'buy_date': today, 'buy_time': now_time,
                            'target_raw': target_raw, 'type': 'ì§€ì •ê°€',
                            'csv_buy_price': buy_price,
                            'csv_slippage': slippage
                        }

            elif "ë§¤ë„" in order_type and status == "ì²´ê²°":
                actual_sell_price = int(self.kiwoom.dynamicCall("GetChejanData(int)", 910))
                stock_name = self.kiwoom.dynamicCall("GetMasterCodeName(QString)", code)
                today = datetime.now().strftime('%Y-%m-%d')
                now_time = datetime.now().strftime('%H:%M:%S')

                sell_target_price = 0
                if code in self.held_stocks and 'sell_target_price' in self.held_stocks[code]:
                    sell_target_price = self.held_stocks[code]['sell_target_price']

                # ì˜¤ë¥˜ ë°©ì§€: ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í•œ ê²½ìš° ì²´ê²°ê°€ì™€ ë™ì¼í•˜ê²Œ ë³´ì •
                if sell_target_price == 0:
                    sell_target_price = actual_sell_price

                self._log_sell_trade(code, stock_name, today, now_time, sell_target_price, actual_sell_price)

            print(f"[ì²´ê²°ì•Œë¦¼] {code} | {status} | {order_no}")

        elif gubun == '1':  # ì”ê³ í†µë³´
            code = self.kiwoom.dynamicCall("GetChejanData(int)", 9001).replace('A', '').strip()
            qty = int(self.kiwoom.dynamicCall("GetChejanData(int)", 930))
            if qty > 0:
                if code in self.held_stocks:
                    self.held_stocks[code]['qty'] = qty
                else:
                    self.held_stocks[code] = {'qty': qty, 'price': 0}
            else:
                if code in self.held_stocks: del self.held_stocks[code]

    def _periodic_check(self):
        now = datetime.now()
        print(f"\n[ì‹œìŠ¤í…œ ì ê²€] {now.strftime('%H:%M:%S')} ì‹¤ì‹œê°„ ê°ì‹œ ì‘ë™ ì¤‘...")

        search_count = len(self.current_conditioned_stocks)
        print(f"  > [ì‹¤ì‹œê°„ ê²€ìƒ‰] í˜„ì¬ ë§¤ìˆ˜ ì¡°ê±´ í¬ì°© ì¢…ëª© ìˆ˜: {search_count}ê°œ")

        overlap_held = len(self.current_conditioned_stocks.intersection(set(self.held_stocks.keys())))
        overlap_order = len(self.current_conditioned_stocks.intersection(set(self.open_buy_orders.keys())))

        print(f"  > [ê³„ì¢Œ í˜„í™©] ë³´ìœ ì¢…ëª©: {len(self.held_stocks)}ê°œ, ë¯¸ì²´ê²°ì£¼ë¬¸: {len(self.open_buy_orders)}ê±´")

        if self.job_queue:
            print(f"  > [ëŒ€ê¸° ì‘ì—…] í˜„ì¬ íì—ì„œ {len(self.job_queue)}ê°œì˜ ë§¤ìˆ˜/ë§¤ë„ ì‘ì—…ì´ ìˆœì°¨ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤.")

        if overlap_held > 0 or overlap_order > 0:
            print(f"  > (ì°¸ê³ ) ê²€ìƒ‰ ì¢…ëª© ì¤‘ {overlap_held}ê°œëŠ” ì´ë¯¸ ë³´ìœ  ì¤‘, {overlap_order}ê°œëŠ” ë§¤ìˆ˜ ì§„í–‰ ì¤‘")

        if now.hour == 15 and now.minute >= 20 and self.open_buy_orders:
            print("[ì¥ë§ˆê°] ë¯¸ì²´ê²° ì·¨ì†Œ")
            for code, order_no in list(self.open_buy_orders.items()):
                self._send_order(code, 3, 0, 0, order_no)
                del self.open_buy_orders[code]
                self._safe_delay(300)

    def _print_slippage_report(self):
        if not self.held_stocks: return
        print(f"\n[ì‹œìŠ¤í…œ] ìŠ¬ë¦¬í”¼ì§€ ë¶„ì„ ({datetime.now().strftime('%H:%M:%S')})")
        print("-" * 100)
        print(f"{'ì¢…ëª©ëª…':<10} | {'ë§¤ìˆ˜ì¼ì‹œ':<20} | {'ëª©í‘œê°€':<10} | {'ë§¤ì…ê°€':<10} | {'ìŠ¬ë¦¬í”¼ì§€%':<10}")
        print("-" * 100)

        total_slippage = 0
        count = 0

        for code, info in self.held_stocks.items():
            name = self.kiwoom.dynamicCall("GetMasterCodeName(QString)", code)
            target = info.get('target_raw', 0)

            buy_price = info.get('csv_buy_price', info['price'])
            slippage = info.get('csv_slippage', 0.0)

            total_slippage += slippage
            count += 1

            print(
                f"{name:<10} | {info.get('buy_date', '')} {info.get('buy_time', '')} | {int(target):<10} | {int(buy_price):<10} | {slippage:.2f}%")

        print("-" * 100)
        if count > 0:
            avg_slippage = total_slippage / count
            print(f"[ì „ì²´ í‰ê·  ìŠ¬ë¦¬í”¼ì§€] {avg_slippage:.2f}%")
        print("-" * 100)
