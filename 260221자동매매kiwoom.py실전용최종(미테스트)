import sys
import time
import os
import pandas as pd  # 데이터 저장/수정용
import numpy as np  # 날짜 계산용
from datetime import datetime
from PyQt5.QtWidgets import *
from PyQt5.QAxContainer import *
from PyQt5.QtCore import *


class Kiwoom(QMainWindow):
    def __init__(self):
        super().__init__()

        # --- [설정 구간] ---
        self.BUY_STRATEGY_NAME = "260218급등기본"
        self.SELL_STRATEGY_NAME = "260218매도식"
        self.CSV_FILE_NAME = "trade_history(real).csv"  # 저장할 파일명

        # [추가] 매수/매도 금액 및 호가 설정
        self.MAX_BUY_AMOUNT = 500000  # 1회 최대 매수 금액 (원)
        self.BUY_ORDER_TYPE = "03"  # 매수 호가구분: "00"(지정가), "03"(시장가)
        self.SELL_ORDER_TYPE = "03"  # 매도 호가구분: "00"(지정가), "03"(시장가)
        # -----------------

        self.account_num = None
        self.bought_today = []  # 오늘 매수한 종목 리스트

        # 보유 종목 관리: { '종목코드': {'qty': 수량, 'price': 단가, ...} }
        self.held_stocks = {}

        # 매수 주문 시점의 메타 데이터 임시 저장 (체결 전까지 보관)
        self.buy_meta_data = {}

        # [신규] TR 요청 데이터 임시 저장용 (동기 통신용)
        self.tr_data_temp = {}

        self.open_buy_orders = {}  # 미체결 매수 주문 관리

        # 현재 실시간 조건 만족 종목 관리 (모니터링용)
        self.current_conditioned_stocks = set()

        # [신규] 작업 대기열(Queue) 시스템 (TR 과부하 및 강제종료 0xC0000409 방지)
        self.job_queue = []
        self.is_processing_job = False  # 작업 중복 실행 방지용 락(Lock)

        # 키움 OCX 생성
        self.kiwoom = QAxWidget("KHOPENAPI.KHOpenAPICtrl.1")

        # API 팝업 억제
        self.kiwoom.dynamicCall("KOA_Functions(QString, QString)", "SetShowMessage", "0")

        # 이벤트 연결
        self.kiwoom.OnEventConnect.connect(self._event_connect)
        self.kiwoom.OnReceiveConditionVer.connect(self._handler_condition_load)
        self.kiwoom.OnReceiveTrData.connect(self._handler_tr_data)
        self.kiwoom.OnReceiveMsg.connect(self._handler_msg)

        try:
            self.kiwoom.OnReceiveTrCondition.connect(self._handler_condition)
        except AttributeError:
            self.kiwoom.OnReceiveCondition.connect(self._handler_condition)

        self.kiwoom.OnReceiveRealCondition.connect(self._handler_real_condition)
        self.kiwoom.OnReceiveChejanData.connect(self._handler_chejan_data)

        # 시스템 점검 및 미체결 취소 타이머 (1분)
        self.periodic_timer = QTimer(self)
        self.periodic_timer.timeout.connect(self._periodic_check)
        self.periodic_timer.start(60000)

        # 슬리피지 분석 리포트 타이머 (5분)
        self.slippage_timer = QTimer(self)
        self.slippage_timer.timeout.connect(self._print_slippage_report)
        self.slippage_timer.start(300000)

        # [수정] 0xC0000409 에러 방지를 위해, 단발성(SingleShot) 타이머로 큐 처리 시작
        QTimer.singleShot(1000, self._process_job_queue)

    # -------------------------------------
    # [유틸] 안전한 딜레이 (GUI/이벤트 멈춤 방지)
    # -------------------------------------
    def _safe_delay(self, ms):
        """time.sleep 대신 사용하여 이벤트 루프가 멈추지 않도록 함"""
        loop = QEventLoop()
        QTimer.singleShot(ms, loop.quit)
        loop.exec_()

    # -------------------------------------
    # [유틸] 엑셀 컬럼 하위 호환성 유지 및 마이그레이션
    # -------------------------------------
    def _migrate_history_columns(self, df):
        rename_map = {
            '5%상승가(보정X)': '매수목표가',
            '목표가(보정X)': '매수목표가',
            '슬리피지(%)': '매수슬리피지(%)',
            '매도가격': '실제매도가',
            '수익률(%)': '실제수익률(%)'
        }
        for old, new in rename_map.items():
            if old in df.columns:
                df = df.rename(columns={old: new})

        # 신규 컬럼이 없으면 빈 문자열로 추가
        for col in ['매도목표가', '매도슬리피지(%)', '합산슬리피지(%)', '테스트수익률(%)']:
            if col not in df.columns:
                df[col] = ''

        return df

    # -------------------------------------
    # [유틸] 호가 단위 계산
    # -------------------------------------
    def _get_hoga_unit(self, price):
        if price < 2000:
            return 1
        elif price < 5000:
            return 5
        elif price < 20000:
            return 10
        elif price < 50000:
            return 50
        elif price < 200000:
            return 100
        elif price < 500000:
            return 500
        else:
            return 1000

    def _adjust_price_to_tick(self, price):
        unit = self._get_hoga_unit(price)
        return int(round(price / unit) * unit)

    # -------------------------------------
    # [핵심] CSV 이력 관리 로직
    # -------------------------------------
    def _log_buy_trade(self, code, stock_name, buy_date, buy_time, target_raw, buy_price, slippage):
        """매수 체결 시: 신규 행 생성 (매도 정보는 공란)"""
        if os.path.exists(self.CSV_FILE_NAME):
            try:
                df_exist = pd.read_csv(self.CSV_FILE_NAME, dtype={'종목코드': str})
                df_exist = self._migrate_history_columns(df_exist)

                df_exist['종목코드'] = df_exist['종목코드'].astype(str).str.replace("'", "").str.zfill(6)
                is_duplicate = not df_exist[
                    (df_exist['종목코드'] == code) &
                    (df_exist['매수일'] == buy_date) &
                    (df_exist['매수시간'] == buy_time)
                    ].empty
                if is_duplicate:
                    return
            except Exception:
                pass

        new_data = {
            '종목코드': f"'{code}",
            '종목명': stock_name,
            '매수일': buy_date,
            '매수시간': buy_time,
            '매수목표가': int(target_raw),
            '실제매입가': buy_price,
            '매수슬리피지(%)': round(slippage, 2),
            '매도일': '',
            '매도시간': '',
            '매도목표가': '',
            '실제매도가': '',
            '매도슬리피지(%)': '',
            '합산슬리피지(%)': '',
            '테스트수익률(%)': '',
            '실제수익률(%)': '',
            '보유기간(일)': ''
        }

        try:
            df_new = pd.DataFrame([new_data])
            if not os.path.exists(self.CSV_FILE_NAME):
                df_new.to_csv(self.CSV_FILE_NAME, index=False, encoding='utf-8-sig')
            else:
                df_new.to_csv(self.CSV_FILE_NAME, mode='a', header=False, index=False, encoding='utf-8-sig')
            print(f"[기록] 매수 이력 저장 완료: {stock_name}")
        except Exception as e:
            print(f"[오류] 매수 기록 저장 실패: {e}")

    def _log_sell_trade(self, code, stock_name, sell_date, sell_time, sell_target_price, actual_sell_price):
        """매도 체결 시: 기존 행을 찾아 매도 정보 업데이트"""
        if not os.path.exists(self.CSV_FILE_NAME):
            print(f"[오류] 매매 기록 파일이 없어 매도 업데이트 실패: {stock_name}")
            return

        try:
            df = pd.read_csv(self.CSV_FILE_NAME, dtype={'종목코드': str})
            df = self._migrate_history_columns(df)

            df['종목코드_순수'] = df['종목코드'].astype(str).str.replace("'", "").str.zfill(6)
            mask = (df['종목코드_순수'] == code) & (df['매도일'].isna() | (df['매도일'] == ''))

            if not df.loc[mask].empty:
                idx = df.loc[mask].index[-1]

                # 기존 데이터 추출 (에러 방지용 예외처리)
                try:
                    buy_target = float(df.loc[idx, '매수목표가'])
                except:
                    buy_target = float(df.loc[idx, '실제매입가'])

                try:
                    buy_price = float(df.loc[idx, '실제매입가'])
                except:
                    buy_price = 0.0

                try:
                    buy_slippage = float(df.loc[idx, '매수슬리피지(%)'])
                except:
                    buy_slippage = 0.0

                buy_date = str(df.loc[idx, '매수일'])

                try:
                    hold_days = np.busday_count(buy_date, sell_date)
                except:
                    hold_days = 0

                # 슬리피지 및 수익률 계산 로직
                sell_slippage = ((
                                             sell_target_price - actual_sell_price) / sell_target_price * 100) if sell_target_price > 0 else 0.0
                total_slippage = buy_slippage + sell_slippage

                test_return = ((sell_target_price - buy_target) / buy_target * 100) if buy_target > 0 else 0.0
                actual_return = ((actual_sell_price - buy_price) / buy_price * 100) if buy_price > 0 else 0.0

                df.loc[idx, '매도일'] = sell_date
                df.loc[idx, '매도시간'] = sell_time
                df.loc[idx, '매도목표가'] = int(sell_target_price)
                df.loc[idx, '실제매도가'] = int(actual_sell_price)
                df.loc[idx, '매도슬리피지(%)'] = round(sell_slippage, 2)
                df.loc[idx, '합산슬리피지(%)'] = round(total_slippage, 2)
                df.loc[idx, '테스트수익률(%)'] = round(test_return, 2)
                df.loc[idx, '실제수익률(%)'] = round(actual_return, 2)
                df.loc[idx, '보유기간(일)'] = hold_days

                df = df.drop(columns=['종목코드_순수'])
                df.to_csv(self.CSV_FILE_NAME, index=False, encoding='utf-8-sig')
                print(f"[기록] 매도 이력 업데이트 완료: {stock_name} (실제수익률: {actual_return:.2f}%)")
            else:
                print(f"[알림] '{stock_name}'의 매수 기록을 찾을 수 없어 매도 기록만 별도로 남길 수 없습니다.")

        except Exception as e:
            print(f"[오류] 매도 기록 업데이트 실패: {e}")

    # -------------------------------------
    # 초기화 체인
    # -------------------------------------
    def _req_outstanding_orders(self):
        print("[시스템] 미체결 주문 내역을 확인합니다...")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "계좌번호", self.account_num)
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "전체종목구분", "0")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "매매구분", "0")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "체결구분", "1")
        self.kiwoom.dynamicCall("CommRqData(QString, QString, int, QString)", "미체결요청", "opt10075", 0, "0102")

    def _req_account_balance(self):
        print("[시스템] 보유 종목(계좌 잔고)을 확인합니다...")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "계좌번호", self.account_num)
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "비밀번호", "")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "비밀번호입력매체구분", "00")
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "조회구분", "2")
        self.kiwoom.dynamicCall("CommRqData(QString, QString, int, QString)", "잔고요청", "opw00018", 0, "0103")

    def _get_stock_info(self, code):
        """TR요청(opt10001)으로 시가, 전일종가 확인 (Sync)"""
        self.tr_data_temp = {}
        self.kiwoom.dynamicCall("SetInputValue(QString, QString)", "종목코드", code)
        res = self.kiwoom.dynamicCall("CommRqData(QString, QString, int, QString)", "주식기본정보요청", "opt10001", 0, "0104")

        if res != 0:
            print(f"[시스템] 서버 과부하로 주식기본정보요청(opt10001) 차단됨 (에러코드: {res})")
            return self.tr_data_temp

        self.tr_event_loop = QEventLoop()
        QTimer.singleShot(3000, self.tr_event_loop.quit)
        self.tr_event_loop.exec_()

        return self.tr_data_temp

    def _handler_tr_data(self, scr_no, rqname, trcode, recordname, prev_next, data_len, err_code, msg, splm_msg):
        if rqname == "미체결요청":
            cnt = self.kiwoom.dynamicCall("GetRepeatCnt(QString, QString)", trcode, rqname)
            for i in range(cnt):
                code = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, i,
                                               "종목코드").strip()
                order_no = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, i,
                                                   "주문번호").strip()
                order_type = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, i,
                                                     "주문구분").strip()
                if "매수" in order_type:
                    self.open_buy_orders[code] = order_no
            print(f"[시스템] 미체결 매수 주문 복원: {len(self.open_buy_orders)}건")
            QTimer.singleShot(200, self._req_account_balance)

        elif rqname == "잔고요청":
            history_df = pd.DataFrame()
            if os.path.exists(self.CSV_FILE_NAME):
                try:
                    history_df = pd.read_csv(self.CSV_FILE_NAME, dtype={'종목코드': str})
                    history_df = self._migrate_history_columns(history_df)
                    history_df['종목코드'] = history_df['종목코드'].astype(str).str.replace("'", "").str.zfill(6)
                except Exception:
                    pass

            cnt = self.kiwoom.dynamicCall("GetRepeatCnt(QString, QString)", trcode, rqname)
            for i in range(cnt):
                code = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, i,
                                               "종목번호").strip()
                code = code.replace("A", "")

                qty = int(self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, i,
                                                  "보유수량").strip())
                price = int(self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, i,
                                                    "매입가").strip())

                if qty > 0:
                    target_raw = 0
                    buy_date = '2026-02-19'
                    buy_time = '09:00:00'
                    csv_buy_price = price
                    csv_slippage = 0.0

                    if not history_df.empty:
                        mask = (history_df['종목코드'] == code) & (history_df['매도일'].isna() | (history_df['매도일'] == ''))
                        if not history_df.loc[mask].empty:
                            last_idx = history_df.loc[mask].index[-1]
                            try:
                                target_raw = int(history_df.loc[last_idx, '매수목표가'])
                                buy_date = str(history_df.loc[last_idx, '매수일'])
                                buy_time = str(history_df.loc[last_idx, '매수시간'])
                                csv_buy_price = float(history_df.loc[last_idx, '실제매입가'])
                                csv_slippage = float(history_df.loc[last_idx, '매수슬리피지(%)'])
                            except Exception:
                                pass

                    if target_raw == 0:
                        prev_price_str = self.kiwoom.dynamicCall("GetMasterLastPrice(QString)", code)
                        prev_price = abs(int(prev_price_str)) if prev_price_str else 0
                        target_raw = int(prev_price * 1.05) if prev_price > 0 else price
                        if target_raw > 0:
                            csv_slippage = ((price - target_raw) / target_raw) * 100

                        # [수정] 엑셀에 누락된 잔고 종목을 자동으로 엑셀에 복구(기입)해주는 로직 부활
                        stock_name = self.kiwoom.dynamicCall("GetMasterCodeName(QString)", code)
                        self._log_buy_trade(code, stock_name, buy_date, buy_time, target_raw, price, csv_slippage)

                    self.held_stocks[code] = {
                        'qty': qty, 'price': price, 'buy_date': buy_date, 'buy_time': buy_time,
                        'target_raw': target_raw, 'type': '지정가',
                        'csv_buy_price': csv_buy_price,
                        'csv_slippage': csv_slippage
                    }

            print(f"[시스템] 보유 종목 리스트 복원: {len(self.held_stocks)}종목")
            self._print_slippage_report()
            QTimer.singleShot(200, self._get_condition_load)

        elif rqname == "주식기본정보요청":
            open_price = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, 0,
                                                 "시가").strip()
            prev_close = self.kiwoom.dynamicCall("GetCommData(QString, QString, int, QString)", trcode, rqname, 0,
                                                 "기준가").strip()

            try:
                op = abs(int(open_price)) if open_price else 0
                pc = abs(int(prev_close)) if prev_close else 0
            except ValueError:
                op = 0
                pc = 0

            self.tr_data_temp = {
                'open': op,
                'prev': pc
            }
            if hasattr(self, 'tr_event_loop') and self.tr_event_loop.isRunning():
                self.tr_event_loop.quit()

    # -------------------------------------
    # 메인 로직
    # -------------------------------------
    def _execute_buy(self, code):
        now = datetime.now().strftime('%H:%M:%S')
        stock_name = self.kiwoom.dynamicCall("GetMasterCodeName(QString)", code)

        if code in self.open_buy_orders:
            print(f"[{now}] [매수스킵] {stock_name}({code}) - 미체결 매수 주문 대기 중")
            return

        if code in self.held_stocks:
            print(f"[{now}] [매수스킵] {stock_name}({code}) - 이미 보유 중인 종목")
            return

        if code in self.bought_today:
            return

        # TR 요청으로 시가, 전일종가 획득
        try:
            info = self._get_stock_info(code)
            open_price = info.get('open', 0)

            prev_price_str = self.kiwoom.dynamicCall("GetMasterLastPrice(QString)", code)
            prev_price = abs(int(prev_price_str)) if prev_price_str else info.get('prev', 0)

        except Exception as e:
            print(f"[{now}] [오류] 가격정보 조회 실패: {code} ({e})")
            return

        if prev_price == 0:
            print(f"[{now}] [매수스킵] {stock_name}({code}) - 가격정보(시가/전일종가) 조회 불가")
            return

        # 목표가 계산 로직: MAX(전일종가 * 1.05, 당일 시가)
        raw_target_price = max(prev_price * 1.05, float(open_price))
        target_raw_int = int(raw_target_price)

        target_price = self._adjust_price_to_tick(raw_target_price)

        quantity = self.MAX_BUY_AMOUNT // target_price

        if quantity == 0:
            print(f"[{now}] [매수불가] {stock_name}({code}) - 단가 초과")
            return

        print(f"[{now}] [자동매수] {stock_name}({code})")
        print(f"  > 전일종가: {prev_price:,}원, 시가: {open_price:,}원")
        print(f"  > 목표가(Max): {target_raw_int:,}원 -> 주문가: {target_price:,}원")
        print(f"  > 주문수량: {quantity}주")

        self.buy_meta_data[code] = {'target_raw': target_raw_int, 'time': now}
        self._send_order(code, 1, quantity, target_price)

        if code not in self.bought_today: self.bought_today.append(code)

    def _execute_sell(self, code):
        now = datetime.now().strftime('%H:%M:%S')
        stock_name = self.kiwoom.dynamicCall("GetMasterCodeName(QString)", code)

        if code in self.bought_today:
            print(f"[{now}] [매도스킵] {stock_name} - 당일 매수 종목")
            return

        if code in self.held_stocks and self.held_stocks[code]['qty'] > 0:
            quantity = self.held_stocks[code]['qty']

            # [기록 로직 추가] 매도 조건이 포착된 '순간'의 현재가를 가져와 '테스트 매도목표가'로 기록
            current_price_str = self.kiwoom.dynamicCall("GetMasterLastPrice(QString)", code)
            sell_target_price = abs(int(current_price_str)) if current_price_str else 0
            self.held_stocks[code]['sell_target_price'] = sell_target_price

            print(f"[{now}] [자동매도] {stock_name} {quantity}주 시장가 매도 (매도목표가: {sell_target_price:,}원)")
            self._send_order(code, 2, quantity, 0)
        else:
            print(f"[{now}] [매도불가] {stock_name} - 잔고 없음")

    # -------------------------------------
    # 작업 큐 처리 (단발성 재귀 호출 방식, 데드락 방지)
    # -------------------------------------
    def _process_job_queue(self):
        """큐에서 작업을 꺼내어 순차 처리 (안정성 확보)"""
        # 통신 작업이 진행 중이면, 0.2초 뒤에 다시 확인
        if self.is_processing_job:
            QTimer.singleShot(200, self._process_job_queue)
            return

        # 대기 중인 작업이 없으면 0.5초 뒤에 다시 확인
        if not self.job_queue:
            QTimer.singleShot(500, self._process_job_queue)
            return

        self.is_processing_job = True  # 문 잠금 (다른 통신 개입 차단)

        try:
            job = self.job_queue.pop(0)
            job_type = job['type']
            code = job['code']

            if job_type == 'BUY':
                self._execute_buy(code)
            elif job_type == 'SELL':
                self._execute_sell(code)
        finally:
            self.is_processing_job = False  # 작업 완전 종료 후 문 열림
            QTimer.singleShot(300, self._process_job_queue)

    # -------------------------------------
    # 이벤트 핸들러
    # -------------------------------------
    def comm_connect(self):
        print("[시스템] 로그인 시도...")
        self.kiwoom.dynamicCall("CommConnect()")
        self.login_event_loop = QEventLoop()
        self.login_event_loop.exec_()

    def _event_connect(self, err_code):
        if err_code == 0:
            print("로그인 성공!")
            self.kiwoom.dynamicCall("KOA_Functions(QString, QString)", "SetShowMessage", "0")

            self._get_account_info()
            QTimer.singleShot(200, self._req_outstanding_orders)
        else:
            print("로그인 실패")
            self.login_event_loop.exit()

    def _handler_msg(self, scr_no, rqname, trcode, msg):
        if "매수" in rqname or "주문" in msg:
            print(f"[서버메시지] {msg}")
        # [추가] 과부하 등 시스템 경고성 메시지도 표시하여 원인 파악 용이
        elif "조회" in msg or "초과" in msg or "제한" in msg:
            print(f"[서버경고] {msg}")

    def after_login(self):
        self.login_event_loop.exit()

    def _get_account_info(self):
        self.account_num = self.kiwoom.dynamicCall("GetLoginInfo(QString)", "ACCNO").split(';')[0]
        print(f"[내 정보] 계좌번호: {self.account_num}")

    def _get_condition_load(self):
        self.kiwoom.dynamicCall("GetConditionLoad()")

    def _handler_condition_load(self, ret, msg):
        if ret == 1:
            print("[시스템] 조건식 로딩 완료.")
            conditions = self.kiwoom.dynamicCall("GetConditionNameList()").split(";")[:-1]
            for c in conditions:
                idx, name = c.split('^')
                if name in [self.BUY_STRATEGY_NAME, self.SELL_STRATEGY_NAME]:
                    print(f"[{name}] 초기 검색 및 실시간 감시 요청...")
                    # [수정] 옵션을 0(1회성)에서 1(실시간)로 변경하여 처음부터 실시간 감시를 확실히 켬
                    self.kiwoom.dynamicCall("SendCondition(QString, QString, int, int)",
                                            "0156" if "매수" in name else "0157", name, int(idx), 1)
                    self._safe_delay(1500)

    def _handler_condition(self, scr_no, code_list, cond_name, cond_index, next):
        now = datetime.now().strftime('%H:%M:%S')
        codes = code_list.split(';')[:-1] if code_list else []
        print(f"\n[{now}] [{cond_name}] 검색 결과: {len(codes)}종목")

        if cond_name.strip() == self.SELL_STRATEGY_NAME.strip():
            sell_targets = [c for c in codes if c in self.held_stocks]
            if sell_targets:
                print(f"  > [매도대상발견] 잔고 중 매도 조건 일치: {len(sell_targets)}종목 발견 (큐에 대기 등록)")
                for code in sell_targets:
                    self.job_queue.append({'type': 'SELL', 'code': code})
            else:
                print(f"  > [매도대상없음] 검색된 종목 중 현재 잔고에 보유한 종목이 없습니다.")

        elif cond_name.strip() == self.BUY_STRATEGY_NAME.strip():
            for code in codes:
                self.current_conditioned_stocks.add(code)
                self.job_queue.append({'type': 'BUY', 'code': code})

        # [수정] 통신이 차단되는 원인이었던 중복 실시간 전환 요청(SendCondition) 코드 삭제 완료

    def _handler_real_condition(self, code, type, cond_name, cond_index):
        if type == 'I':
            if cond_name.strip() == self.BUY_STRATEGY_NAME.strip():
                self.current_conditioned_stocks.add(code)
                self.job_queue.append({'type': 'BUY', 'code': code})
            elif cond_name.strip() == self.SELL_STRATEGY_NAME.strip():
                self.job_queue.append({'type': 'SELL', 'code': code})
        elif type == 'D' and cond_name.strip() == self.BUY_STRATEGY_NAME.strip():
            self.current_conditioned_stocks.discard(code)

    def _send_order(self, code, order_type, quantity, price, order_no=""):
        if order_type == 1:  # 신규매수
            hoga = self.BUY_ORDER_TYPE
            if hoga == "03": price = 0  # 시장가는 가격 0 전송
        elif order_type == 2:  # 신규매도
            hoga = self.SELL_ORDER_TYPE
            if hoga == "03":
                price = 0
            elif hoga == "00" and price == 0:
                # 매도시 지정가로 설정했는데 가격이 0으로 넘어왔을 경우 현재가로 보정
                current_price_str = self.kiwoom.dynamicCall("GetMasterLastPrice(QString)", code)
                price = abs(int(current_price_str)) if current_price_str else 0
        else:  # 매수취소 등 기타
            hoga = "00"

        self.kiwoom.dynamicCall("SendOrder(QString, QString, QString, int, QString, int, int, QString, QString)",
                                ["send_order", "0101", self.account_num, order_type, code, quantity, price, hoga,
                                 order_no])

    def _handler_chejan_data(self, gubun, item_cnt, fid_list):
        if gubun == '0':  # 접수/체결
            status = self.kiwoom.dynamicCall("GetChejanData(int)", 913)
            code = self.kiwoom.dynamicCall("GetChejanData(int)", 9001).replace('A', '').strip()
            order_no = self.kiwoom.dynamicCall("GetChejanData(int)", 9203)
            order_type = self.kiwoom.dynamicCall("GetChejanData(int)", 905)

            if "매수" in order_type:
                if status == "접수":
                    self.open_buy_orders[code] = order_no
                elif status == "체결":
                    if code in self.open_buy_orders: del self.open_buy_orders[code]

                    if code not in self.held_stocks:
                        buy_price = int(self.kiwoom.dynamicCall("GetChejanData(int)", 910))
                        stock_name = self.kiwoom.dynamicCall("GetMasterCodeName(QString)", code)
                        today = datetime.now().strftime('%Y-%m-%d')
                        now_time = datetime.now().strftime('%H:%M:%S')

                        target_raw = 0
                        if code in self.buy_meta_data: target_raw = self.buy_meta_data[code]['target_raw']

                        slippage = 0
                        if target_raw > 0:
                            slippage = ((buy_price - target_raw) / target_raw) * 100

                        self._log_buy_trade(code, stock_name, today, now_time, target_raw, buy_price, slippage)

                        self.held_stocks[code] = {
                            'qty': 0, 'price': buy_price, 'buy_date': today, 'buy_time': now_time,
                            'target_raw': target_raw, 'type': '지정가',
                            'csv_buy_price': buy_price,
                            'csv_slippage': slippage
                        }

            elif "매도" in order_type and status == "체결":
                actual_sell_price = int(self.kiwoom.dynamicCall("GetChejanData(int)", 910))
                stock_name = self.kiwoom.dynamicCall("GetMasterCodeName(QString)", code)
                today = datetime.now().strftime('%Y-%m-%d')
                now_time = datetime.now().strftime('%H:%M:%S')

                sell_target_price = 0
                if code in self.held_stocks and 'sell_target_price' in self.held_stocks[code]:
                    sell_target_price = self.held_stocks[code]['sell_target_price']

                # 오류 방지: 데이터를 불러오지 못한 경우 체결가와 동일하게 보정
                if sell_target_price == 0:
                    sell_target_price = actual_sell_price

                self._log_sell_trade(code, stock_name, today, now_time, sell_target_price, actual_sell_price)

            print(f"[체결알림] {code} | {status} | {order_no}")

        elif gubun == '1':  # 잔고통보
            code = self.kiwoom.dynamicCall("GetChejanData(int)", 9001).replace('A', '').strip()
            qty = int(self.kiwoom.dynamicCall("GetChejanData(int)", 930))
            if qty > 0:
                if code in self.held_stocks:
                    self.held_stocks[code]['qty'] = qty
                else:
                    self.held_stocks[code] = {'qty': qty, 'price': 0}
            else:
                if code in self.held_stocks: del self.held_stocks[code]

    def _periodic_check(self):
        now = datetime.now()
        print(f"\n[시스템 점검] {now.strftime('%H:%M:%S')} 실시간 감시 작동 중...")

        search_count = len(self.current_conditioned_stocks)
        print(f"  > [실시간 검색] 현재 매수 조건 포착 종목 수: {search_count}개")

        overlap_held = len(self.current_conditioned_stocks.intersection(set(self.held_stocks.keys())))
        overlap_order = len(self.current_conditioned_stocks.intersection(set(self.open_buy_orders.keys())))

        print(f"  > [계좌 현황] 보유종목: {len(self.held_stocks)}개, 미체결주문: {len(self.open_buy_orders)}건")

        if self.job_queue:
            print(f"  > [대기 작업] 현재 큐에서 {len(self.job_queue)}개의 매수/매도 작업이 순차 진행 중입니다.")

        if overlap_held > 0 or overlap_order > 0:
            print(f"  > (참고) 검색 종목 중 {overlap_held}개는 이미 보유 중, {overlap_order}개는 매수 진행 중")

        if now.hour == 15 and now.minute >= 20 and self.open_buy_orders:
            print("[장마감] 미체결 취소")
            for code, order_no in list(self.open_buy_orders.items()):
                self._send_order(code, 3, 0, 0, order_no)
                del self.open_buy_orders[code]
                self._safe_delay(300)

    def _print_slippage_report(self):
        if not self.held_stocks: return
        print(f"\n[시스템] 슬리피지 분석 ({datetime.now().strftime('%H:%M:%S')})")
        print("-" * 100)
        print(f"{'종목명':<10} | {'매수일시':<20} | {'목표가':<10} | {'매입가':<10} | {'슬리피지%':<10}")
        print("-" * 100)

        total_slippage = 0
        count = 0

        for code, info in self.held_stocks.items():
            name = self.kiwoom.dynamicCall("GetMasterCodeName(QString)", code)
            target = info.get('target_raw', 0)

            buy_price = info.get('csv_buy_price', info['price'])
            slippage = info.get('csv_slippage', 0.0)

            total_slippage += slippage
            count += 1

            print(
                f"{name:<10} | {info.get('buy_date', '')} {info.get('buy_time', '')} | {int(target):<10} | {int(buy_price):<10} | {slippage:.2f}%")

        print("-" * 100)
        if count > 0:
            avg_slippage = total_slippage / count
            print(f"[전체 평균 슬리피지] {avg_slippage:.2f}%")
        print("-" * 100)
